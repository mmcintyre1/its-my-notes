---
last_modified_date: "2021-01-26 13:14:26.949657"
nav_exclude: true
---
# Database Encapsulation
Recently, we had a late-breaking request come in. A team was under the hood updating components for log4j, and noticed they were running SQL Server 2008 and figured now was a better time than any to update to SQL Server 2019. The database they were updating basically formed the backbone of our Content Delivery Network for PDFs, storing hundreds of millions of primary key identifiers and the location of the PDF on one of several filers. Dozens of our components wrote to this database, many likely executing raw SQL to write directly to the database. This team had already updated all the replicas, now it was time to update the master.

This is a situation where two engineering practices would have made this work trivial, but because we didn't have them, it made this an analysis project. RDBMS major version updates almost always require code changes for services that hit those databases. Inevitably, a major version updates a data type or an encoding and this breaks some assumption from a consuming service. An example would be that in MySQL 8 (from 5.7), the default charset was changed from UTF8MB3 to UTF8MB4, causing a warning in things like Django that wasn't handled properly causing errors. There are probably dozens of other examples. Thing is, bumping a database version is rarely fast and easy, despite what DBAs attest.

This means you need a lower environment to test things in, otherwise you are playing with fire in live. If you can only operate in live, you can be sure you'll be rolling changes back and forward a few times as you essentially prove out that there are no new corner cases that break functionality. And the thing is, you don't necessarily even know if all functionality is preserved when you bump the version, since the problem might be in an infrequently called operation. This would be something that integration or end to end tests would catch, but if you don't have a lower environment to test in, your testing is likely in poor shape as well.

One other thing that would've made life much easier is to have had a service in front of the database that handles all database operations. Encapsulating database access in a service layer might not be a valid use case for a small little Flask app, but this level of [indirection](https://en.wikipedia.org/wiki/Indirection) would've been really useful. Instead of needing to change every single service, you'd just need to change the service layer on top of the database and preserve the contract. No consuming services would need to be updated, and all you'd have to account for is the outage (unless you have some High Availability cluster so you can patch one database at a time with diminished performance but still basically available).