<!DOCTYPE html>
<html lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge">

  

  <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

  <link rel="stylesheet" href="/assets/css/just-the-docs-default.css">
  <link rel="stylesheet" href="/assets/css/native.css">

  
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-M6EEXPRNWS"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());

    gtag('config', 'G-M6EEXPRNWS', { 'anonymize_ip': true });
  </script>

  

  
  <script type="text/javascript" src="/assets/js/vendor/lunr.min.js"></script>
  
  <script type="text/javascript" src="/assets/js/just-the-docs.js"></script>

  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Designing Data Intensive Applications | Notes</title>
<meta name="generator" content="Jekyll v3.9.2">
<meta property="og:title" content="Designing Data Intensive Applications">
<meta property="og:locale" content="en_US">
<meta name="description" content="My Notes">
<meta property="og:description" content="My Notes">
<link rel="canonical" href="https://itsmynotes.com/notes/tech_books/designing-data-intensive-applications">
<meta property="og:url" content="https://itsmynotes.com/notes/tech_books/designing-data-intensive-applications">
<meta property="og:site_name" content="Notes">
<meta property="og:type" content="website">
<meta name="twitter:card" content="summary">
<meta property="twitter:title" content="Designing Data Intensive Applications">
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebPage","description":"My Notes","headline":"Designing Data Intensive Applications","url":"https://itsmynotes.com/notes/tech_books/designing-data-intensive-applications"}</script>
<!-- End Jekyll SEO tag -->


  

</head>
<body>
  <a class="skip-to-main" href="#main-content">Skip to main content</a>
  <svg xmlns="http://www.w3.org/2000/svg" class="d-none">
  <symbol id="svg-link" viewbox="0 0 24 24">
  <title>Link</title>
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewbox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-link">
    <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path>
  </svg>
</symbol>

  <symbol id="svg-menu" viewbox="0 0 24 24">
  <title>Menu</title>
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewbox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu">
    <line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line>
  </svg>
</symbol>

  <symbol id="svg-arrow-right" viewbox="0 0 24 24">
  <title>Expand</title>
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewbox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-right">
    <polyline points="9 18 15 12 9 6"></polyline>
  </svg>
</symbol>

  <!-- Feather. MIT License: https://github.com/feathericons/feather/blob/master/LICENSE -->
<symbol id="svg-external-link" width="24" height="24" viewbox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-external-link">
  <title id="svg-external-link-title">(external link)</title>
  <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line>
</symbol>

  
    <symbol id="svg-doc" viewbox="0 0 24 24">
  <title>Document</title>
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewbox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file">
    <path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"></path><polyline points="13 2 13 9 20 9"></polyline>
  </svg>
</symbol>

    <symbol id="svg-search" viewbox="0 0 24 24">
  <title>Search</title>
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewbox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-search">
    <circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line>
  </svg>
</symbol>

  
  
    <!-- Bootstrap Icons. MIT License: https://github.com/twbs/icons/blob/main/LICENSE.md -->
<symbol id="svg-copy" viewbox="0 0 16 16">
  <title>Copy</title>
  <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-clipboard" viewbox="0 0 16 16">
    <path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1h1a1 1 0 0 1 1 1V14a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V3.5a1 1 0 0 1 1-1h1v-1z"></path>
    <path d="M9.5 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h3zm-3-1A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3z"></path>
  </svg>
</symbol>
<symbol id="svg-copied" viewbox="0 0 16 16">
  <title>Copied</title>
  <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-clipboard-check-fill" viewbox="0 0 16 16">
    <path d="M6.5 0A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3Zm3 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h3Z"></path>
    <path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1A2.5 2.5 0 0 1 9.5 5h-3A2.5 2.5 0 0 1 4 2.5v-1Zm6.854 7.354-3 3a.5.5 0 0 1-.708 0l-1.5-1.5a.5.5 0 0 1 .708-.708L7.5 10.793l2.646-2.647a.5.5 0 0 1 .708.708Z"></path>
  </svg>
</symbol>

  
</svg>

  <div class="side-bar">
  <div class="site-header" role="banner">
    <a href="/" class="site-title lh-tight">
  Notes

</a>
    <button id="menu-button" class="site-button btn-reset" aria-label="Toggle menu" aria-pressed="false">
      <svg viewbox="0 0 24 24" class="icon" aria-hidden="true"><use xlink:href="#svg-menu"></use></svg>
    </button>
  </div>

  <nav aria-label="Main" id="site-nav" class="site-nav">
  
  
    <ul class="nav-list">
<li class="nav-list-item">
<button class="nav-list-expander btn-reset" aria-label="toggle items in Projects category" aria-pressed="false">
      <svg viewbox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg>
    </button><a href="/notes/projects" class="nav-list-link">Projects</a><ul class="nav-list"></ul>
</li>
<li class="nav-list-item">
<button class="nav-list-expander btn-reset" aria-label="toggle items in Vocabulary category" aria-pressed="false">
      <svg viewbox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg>
    </button><a href="/notes/vocabulary" class="nav-list-link">Vocabulary</a><ul class="nav-list"></ul>
</li>
<li class="nav-list-item">
<button class="nav-list-expander btn-reset" aria-label="toggle items in Business Books category" aria-pressed="false">
      <svg viewbox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg>
    </button><a href="/notes/business-books" class="nav-list-link">Business Books</a><ul class="nav-list"></ul>
</li>
<li class="nav-list-item">
<button class="nav-list-expander btn-reset" aria-label="toggle items in Other Books category" aria-pressed="false">
      <svg viewbox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg>
    </button><a href="/notes/other-books" class="nav-list-link">Other Books</a><ul class="nav-list"></ul>
</li>
<li class="nav-list-item">
<button class="nav-list-expander btn-reset" aria-label="toggle items in Educational Books category" aria-pressed="false">
      <svg viewbox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg>
    </button><a href="/notes/educational-books" class="nav-list-link">Educational Books</a><ul class="nav-list"></ul>
</li>
<li class="nav-list-item">
<button class="nav-list-expander btn-reset" aria-label="toggle items in Articles category" aria-pressed="false">
      <svg viewbox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg>
    </button><a href="/notes/articles" class="nav-list-link">Articles</a><ul class="nav-list"></ul>
</li>
<li class="nav-list-item">
<button class="nav-list-expander btn-reset" aria-label="toggle items in Quotes category" aria-pressed="false">
      <svg viewbox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg>
    </button><a href="/notes/quotes" class="nav-list-link">Quotes</a><ul class="nav-list"></ul>
</li>
<li class="nav-list-item">
<button class="nav-list-expander btn-reset" aria-label="toggle items in Classes category" aria-pressed="false">
      <svg viewbox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg>
    </button><a href="/notes/classes" class="nav-list-link">Classes</a><ul class="nav-list"></ul>
</li>
<li class="nav-list-item">
<button class="nav-list-expander btn-reset" aria-label="toggle items in Tech Books category" aria-pressed="false">
      <svg viewbox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg>
    </button><a href="/notes/tech-books" class="nav-list-link">Tech Books</a><ul class="nav-list"></ul>
</li>
<li class="nav-list-item">
<button class="nav-list-expander btn-reset" aria-label="toggle items in Podcasts category" aria-pressed="false">
      <svg viewbox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg>
    </button><a href="/notes/podcasts" class="nav-list-link">Podcasts</a><ul class="nav-list"></ul>
</li>
</ul>

  
</nav>


  
  
    <footer class="site-footer">
      This site uses <a href="https://github.com/just-the-docs/just-the-docs">Just the Docs</a>, a documentation theme for Jekyll.
    </footer>
  
</div>

  <div class="main" id="top">
    <div id="main-header" class="main-header">
  
    

<div class="search" role="search">
  <div class="search-input-wrap">
    <input type="text" id="search-input" class="search-input" tabindex="0" placeholder="Search Notes" aria-label="Search Notes" autocomplete="off">
    <label for="search-input" class="search-label"><svg viewbox="0 0 24 24" class="search-icon"><use xlink:href="#svg-search"></use></svg></label>
  </div>
  <div id="search-results" class="search-results"></div>
</div>

  
  
  
    <nav aria-label="Auxiliary" class="aux-nav">
  <ul class="aux-nav-list">
    
      <li class="aux-nav-list-item">
        <a href="https://github.com/mmcintyre1/its-my-notes" class="site-button">
          It's My Notes on GitHub
        </a>
      </li>
    
  </ul>
</nav>

  
</div>

    <div class="main-content-wrap">
      <nav aria-label="Breadcrumb" class="breadcrumb-nav">
  <ol class="breadcrumb-nav-list">
  
    <li class="breadcrumb-nav-list-item"><a href="/notes/tech-books">Tech Books</a></li>
  <li class="breadcrumb-nav-list-item"><span>Designing Data Intensive Applications</span></li>
  </ol>
</nav>
      <div id="main-content" class="main-content">
        <main>
          
            <h1 class="no_toc" id="designing-data-intensive-applications">
  
  
    <a href="#designing-data-intensive-applications" class="anchor-heading" aria-labelledby="designing-data-intensive-applications"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Designing Data Intensive Applications
  
  
</h1>
    

<details open="">
  <summary>
    Table of contents
  </summary>
<ol id="markdown-toc">
  <li>
<a href="#chapter-1-reliable-scalable-and-maintainable-applications" id="markdown-toc-chapter-1-reliable-scalable-and-maintainable-applications">Chapter 1: Reliable, Scalable, and Maintainable Applications</a>    <ol>
      <li><a href="#reliability" id="markdown-toc-reliability">Reliability</a></li>
      <li><a href="#scalability" id="markdown-toc-scalability">Scalability</a></li>
      <li><a href="#maintainability" id="markdown-toc-maintainability">Maintainability</a></li>
      <li><a href="#chapter-summary" id="markdown-toc-chapter-summary">Chapter Summary</a></li>
    </ol>
  </li>
  <li>
<a href="#chapter-2-data-models-and-query-languages" id="markdown-toc-chapter-2-data-models-and-query-languages">Chapter 2: Data Models and Query Languages</a>    <ol>
      <li><a href="#relational-model" id="markdown-toc-relational-model">Relational Model</a></li>
      <li><a href="#document-model" id="markdown-toc-document-model">Document Model</a></li>
      <li><a href="#graph-model" id="markdown-toc-graph-model">Graph Model</a></li>
      <li><a href="#relational-vs-document" id="markdown-toc-relational-vs-document">Relational vs Document</a></li>
      <li><a href="#query-languages" id="markdown-toc-query-languages">Query Languages</a></li>
      <li><a href="#chapter-summary-1" id="markdown-toc-chapter-summary-1">Chapter Summary</a></li>
    </ol>
  </li>
  <li>
<a href="#chapter-3-storage-and-retrieval" id="markdown-toc-chapter-3-storage-and-retrieval">Chapter 3: Storage and Retrieval</a>    <ol>
      <li><a href="#indexes" id="markdown-toc-indexes">Indexes</a></li>
      <li><a href="#transactions-vs-analytics" id="markdown-toc-transactions-vs-analytics">Transactions vs Analytics</a></li>
      <li><a href="#data-warehouses-and-column-oriented-storage" id="markdown-toc-data-warehouses-and-column-oriented-storage">Data Warehouses and Column-Oriented Storage</a></li>
      <li><a href="#chapter-summary-2" id="markdown-toc-chapter-summary-2">Chapter Summary</a></li>
    </ol>
  </li>
  <li>
<a href="#chapter-4-encoding-and-evolution" id="markdown-toc-chapter-4-encoding-and-evolution">Chapter 4: Encoding and Evolution</a>    <ol>
      <li><a href="#formats-for-encoding-data" id="markdown-toc-formats-for-encoding-data">Formats for Encoding Data</a></li>
      <li>
<a href="#modes-of-dataflow" id="markdown-toc-modes-of-dataflow">Modes of Dataflow</a>        <ol>
          <li><a href="#dataflow-through-databases" id="markdown-toc-dataflow-through-databases">Dataflow through Databases</a></li>
          <li><a href="#dataflow-through-services-rest-and-rpc" id="markdown-toc-dataflow-through-services-rest-and-rpc">Dataflow through Services: REST and RPC</a></li>
          <li><a href="#dataflow-though-async-messages" id="markdown-toc-dataflow-though-async-messages">Dataflow though async messages</a></li>
        </ol>
      </li>
      <li><a href="#chapter-summary-3" id="markdown-toc-chapter-summary-3">Chapter Summary</a></li>
    </ol>
  </li>
  <li>
<a href="#chapter-5-replication" id="markdown-toc-chapter-5-replication">Chapter 5: Replication</a>    <ol>
      <li><a href="#leader-based-replication" id="markdown-toc-leader-based-replication">Leader-based replication</a></li>
      <li><a href="#multi-leader-replication" id="markdown-toc-multi-leader-replication">Multi-Leader Replication</a></li>
      <li><a href="#leaderless-replication" id="markdown-toc-leaderless-replication">Leaderless Replication</a></li>
      <li><a href="#chapter-summary-4" id="markdown-toc-chapter-summary-4">Chapter Summary</a></li>
    </ol>
  </li>
  <li>
<a href="#chapter-6-partitioning" id="markdown-toc-chapter-6-partitioning">Chapter 6: Partitioning</a>    <ol>
      <li><a href="#partitioning-of-key-value-data" id="markdown-toc-partitioning-of-key-value-data">Partitioning of Key-Value Data</a></li>
      <li><a href="#partitioning--secondary-indexes" id="markdown-toc-partitioning--secondary-indexes">Partitioning &amp; Secondary Indexes</a></li>
      <li><a href="#rebalancing-partitions" id="markdown-toc-rebalancing-partitions">Rebalancing Partitions</a></li>
      <li><a href="#request-routing" id="markdown-toc-request-routing">Request Routing</a></li>
      <li><a href="#chapter-summary-5" id="markdown-toc-chapter-summary-5">Chapter Summary</a></li>
    </ol>
  </li>
  <li>
<a href="#chapter-7-transactions" id="markdown-toc-chapter-7-transactions">Chapter 7: Transactions</a>    <ol>
      <li><a href="#what-is-a-transaction" id="markdown-toc-what-is-a-transaction">What is a Transaction?</a></li>
      <li><a href="#acid" id="markdown-toc-acid">ACID</a></li>
      <li>
<a href="#weak-non-serializable-isolation-levels" id="markdown-toc-weak-non-serializable-isolation-levels">Weak (Non-Serializable) Isolation Levels</a>        <ol>
          <li><a href="#read-committed" id="markdown-toc-read-committed">Read Committed</a></li>
          <li><a href="#snapshot-isolation-and-repeatable-read" id="markdown-toc-snapshot-isolation-and-repeatable-read">Snapshot Isolation and Repeatable Read</a></li>
        </ol>
      </li>
      <li>
<a href="#serializability" id="markdown-toc-serializability">Serializability</a>        <ol>
          <li><a href="#actual-serial-execution" id="markdown-toc-actual-serial-execution">Actual Serial Execution</a></li>
          <li><a href="#two-phase-locking-2pl" id="markdown-toc-two-phase-locking-2pl">Two-Phase Locking (2PL)</a></li>
          <li><a href="#serializable-snapshot-isolation-ssi" id="markdown-toc-serializable-snapshot-isolation-ssi">Serializable Snapshot Isolation (SSI)</a></li>
        </ol>
      </li>
      <li><a href="#chapter-summary-6" id="markdown-toc-chapter-summary-6">Chapter Summary</a></li>
    </ol>
  </li>
  <li>
<a href="#chapter-8-the-trouble-with-distributed-systems" id="markdown-toc-chapter-8-the-trouble-with-distributed-systems">Chapter 8: The Trouble with Distributed Systems</a>    <ol>
      <li><a href="#faults-and-partial-failures" id="markdown-toc-faults-and-partial-failures">Faults and Partial Failures</a></li>
      <li><a href="#unreliable-networks" id="markdown-toc-unreliable-networks">Unreliable Networks</a></li>
      <li><a href="#unreliable-clocks" id="markdown-toc-unreliable-clocks">Unreliable Clocks</a></li>
      <li><a href="#chapter-summary-7" id="markdown-toc-chapter-summary-7">Chapter Summary</a></li>
    </ol>
  </li>
  <li>
<a href="#chapter-9-consistency-and-consensus" id="markdown-toc-chapter-9-consistency-and-consensus">Chapter 9: Consistency and Consensus</a>    <ol>
      <li><a href="#consistency-guarantees" id="markdown-toc-consistency-guarantees">Consistency Guarantees</a></li>
      <li><a href="#linearizability" id="markdown-toc-linearizability">Linearizability</a></li>
      <li><a href="#ordering-guarantees" id="markdown-toc-ordering-guarantees">Ordering Guarantees</a></li>
      <li><a href="#distributed-transactions-and-consensus" id="markdown-toc-distributed-transactions-and-consensus">Distributed Transactions and Consensus</a></li>
      <li><a href="#chapter-summary-8" id="markdown-toc-chapter-summary-8">Chapter Summary</a></li>
    </ol>
  </li>
  <li>
<a href="#chapter-10-batch-processing" id="markdown-toc-chapter-10-batch-processing">Chapter 10: Batch Processing</a>    <ol>
      <li><a href="#batch-processing-with-unix-tools" id="markdown-toc-batch-processing-with-unix-tools">Batch Processing with Unix Tools</a></li>
      <li><a href="#mapreduce-and-distributed-filesystems" id="markdown-toc-mapreduce-and-distributed-filesystems">MapReduce and Distributed Filesystems</a></li>
      <li><a href="#beyond-mapreduce" id="markdown-toc-beyond-mapreduce">Beyond MapReduce</a></li>
      <li><a href="#chapter-summary-9" id="markdown-toc-chapter-summary-9">Chapter Summary</a></li>
    </ol>
  </li>
  <li>
<a href="#chapter-11-stream-processing" id="markdown-toc-chapter-11-stream-processing">Chapter 11: Stream Processing</a>    <ol>
      <li><a href="#transmitting-event-streams" id="markdown-toc-transmitting-event-streams">Transmitting Event Streams</a></li>
      <li><a href="#databases-and-streams" id="markdown-toc-databases-and-streams">Databases and Streams</a></li>
      <li><a href="#processing-streams" id="markdown-toc-processing-streams">Processing Streams</a></li>
      <li><a href="#chapter-summary-10" id="markdown-toc-chapter-summary-10">Chapter Summary</a></li>
    </ol>
  </li>
  <li>
<a href="#chapter-12-the-future-of-data-systems" id="markdown-toc-chapter-12-the-future-of-data-systems">Chapter 12: The Future of Data Systems</a>    <ol>
      <li><a href="#data-integration" id="markdown-toc-data-integration">Data Integration</a></li>
      <li><a href="#unbundling-databases" id="markdown-toc-unbundling-databases">Unbundling Databases</a></li>
      <li><a href="#aiming-for-correctness" id="markdown-toc-aiming-for-correctness">Aiming for Correctness</a></li>
    </ol>
  </li>
</ol>

</details>
<h1 id="chapter-1-reliable-scalable-and-maintainable-applications">
  
  
    <a href="#chapter-1-reliable-scalable-and-maintainable-applications" class="anchor-heading" aria-labelledby="chapter-1-reliable-scalable-and-maintainable-applications"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Chapter 1: Reliable, Scalable, and Maintainable Applications
  
  
</h1>
    
<h2 class="no_toc" id="data-systems">
  
  
    <a href="#data-systems" class="anchor-heading" aria-labelledby="data-systems"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Data Systems
  
  
</h2>
    
<p>We can group data components (databases, caches, queues, etc.) under the umbrella of data systems instead of as separate components because</p>
<ol>
  <li>many new systems have emerged that blur the typical line (Kafka, Redis)</li>
  <li>many use cases are covered by stitching together data components with application code</li>
</ol>
<h2 class="no_toc" id="three-concerns-for-software-systems">
  
  
    <a href="#three-concerns-for-software-systems" class="anchor-heading" aria-labelledby="three-concerns-for-software-systems"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Three concerns for software systems
  
  
</h2>
    
<ol>
  <li>
<em>Reliability</em>
    <ul>
      <li>The system should continue to work correctly even in the face of adversity</li>
    </ul>
  </li>
  <li>
<em>Scalability</em>
    <ul>
      <li>As the system grows, there should be reasonable ways of dealing with growth</li>
    </ul>
  </li>
  <li>
<em>Maintainability</em>
    <ul>
      <li>Over time, many different people will work on the system, and they should all be able to work on it productively</li>
    </ul>
  </li>
</ol>
<h2 id="reliability">
  
  
    <a href="#reliability" class="anchor-heading" aria-labelledby="reliability"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Reliability
  
  
</h2>
    
<ul>
  <li>Things that can go wrong are called faults, and a system that can withstand them is fault-tolerant or resilient</li>
  <li>fault: component of system deviates from spec</li>
  <li>failure: (different from a fault) when the system stops providing the required service to a user</li>
  <li>we generally prefer tolerating faults over preventing faults</li>
</ul>
<h3 class="no_toc" id="types-of-faults">
  
  
    <a href="#types-of-faults" class="anchor-heading" aria-labelledby="types-of-faults"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Types of Faults
  
  
</h3>
    
<h4 class="no_toc" id="hardware-faults">
  
  
    <a href="#hardware-faults" class="anchor-heading" aria-labelledby="hardware-faults"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Hardware Faults
  
  
</h4>
    
<ul>
  <li>e.g. hard disks crash, RAM becomes faulty, etc
    <ul>
      <li>hard disks have a mean time to failure (MTTF) of about 10 to 50 years</li>
      <li>typically we can add redundancy to a system or individual components by adding additional hardware (additional machines, backup generators, etc)</li>
      <li>move toward systems that can tolerate loss of entire machines (Netflix’s Chaos Engine takes machines offline to test recovery)</li>
    </ul>
  </li>
</ul>
<h4 class="no_toc" id="software-faults">
  
  
    <a href="#software-faults" class="anchor-heading" aria-labelledby="software-faults"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Software Faults
  
  
</h4>
    
<ul>
  <li>systematic error within system</li>
  <li>lots of small things can help minimize software faults: thinking about assumptions and interactions, process isolation, data observation</li>
</ul>
<h4 class="no_toc" id="human-errors">
  
  
    <a href="#human-errors" class="anchor-heading" aria-labelledby="human-errors"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Human Errors
  
  
</h4>
    
<ul>
  <li>might be leading cause of errors</li>
  <li>mitigating design choices can be:
    <ul>
      <li>build well-designed abstractions, APIs, and admin interfaces, make it easy to ‘do the right thing’</li>
      <li>use fully featured sandbox environments</li>
      <li>test thoroughly at all levels (unit tests, whole-system integration tests, manual tests)</li>
      <li>make recovery quick and easy</li>
      <li>build detailed and clear monitoring (telemetry)</li>
    </ul>
  </li>
</ul>
<h2 id="scalability">
  
  
    <a href="#scalability" class="anchor-heading" aria-labelledby="scalability"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Scalability
  
  
</h2>
    
<p>the term we use to describe a system’s ability to cope with increased load</p>
<h3 class="no_toc" id="describing-load">
  
  
    <a href="#describing-load" class="anchor-heading" aria-labelledby="describing-load"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Describing Load
  
  
</h3>
    
<ul>
  <li>load on a system can be described with a few numbers which we call <em>load parameters</em>
</li>
  <li>the best choice of load parameters depends on architecture of your system: could be requests/second, or ratio of reads/writes to a database</li>
  <li>
<em>fan-out</em>: in transaction processing systems, describes the number of requests to other services that we need to make in order to serve one incoming request</li>
</ul>
<h3 class="no_toc" id="describing-performance">
  
  
    <a href="#describing-performance" class="anchor-heading" aria-labelledby="describing-performance"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Describing Performance
  
  
</h3>
    
<ul>
  <li>when you increase load parameters:
    <ul>
      <li>and keep system resources the same, how is performance affected</li>
      <li>how much do you need to increase resources to keep performance the same</li>
    </ul>
  </li>
  <li>in batch processing systems (like Hadoop) we care about throughput</li>
  <li>in online systems, we care about response time</li>
  <li>
<em>latency</em>: time request is waiting to be handled</li>
  <li>
<em>response time</em>: total time a client sees, so time to process (service time), queuing delays, etc</li>
  <li>measuring performance
    <ul>
      <li>we use arithmetic mean (synonymous with average), or median with percentiles</li>
      <li>p95, p99, p999 (95%, 99%, 99.9%) to reflect thresholds of percentiles past the median</li>
      <li>typically used in service level objectives (SLO) and service level agreements (SLA)</li>
    </ul>
  </li>
  <li>
<em>head of line blocking</em>: it only takes a small number of slow responses to hold up the processing of subsequent requests (packet at front holds up a line of packets)</li>
</ul>
<h3 class="no_toc" id="coping-with-load">
  
  
    <a href="#coping-with-load" class="anchor-heading" aria-labelledby="coping-with-load"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Coping with Load
  
  
</h3>
    
<ul>
  <li>
<em>scaling up</em> - vertical scaling, moving to a more powerful machine</li>
  <li>
<em>scaling out</em> - horizontal scaling, distributing the load across multiple smaller machines
    <ul>
      <li>
<em>shared-nothing architecture</em> - distributing load across multiple machines</li>
    </ul>
  </li>
  <li>some systems are <em>elastic</em> (scaled automatically based on load) while some are scaled manually</li>
  <li>
<em>magic scaling sauce</em> - the false idea that there is a one size fits all solution to scaling</li>
  <li>an architecture that scales well for a particular application is built around assumption of which operations will be common and which will be rare (informed by <em>load parameters</em>)</li>
</ul>
<h2 id="maintainability">
  
  
    <a href="#maintainability" class="anchor-heading" aria-labelledby="maintainability"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Maintainability
  
  
</h2>
    
<p>The majority of the cost of software is not in its initial development but ongoing maintenance</p>
<h3 class="no_toc" id="operability">
  
  
    <a href="#operability" class="anchor-heading" aria-labelledby="operability"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Operability
  
  
</h3>
    
<p>make it easy for operations teams to keep systems running smoothly</p>
<h3 class="no_toc" id="simplicity">
  
  
    <a href="#simplicity" class="anchor-heading" aria-labelledby="simplicity"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Simplicity
  
  
</h3>
    
<p>make it easy for new engineers to understand the system by removing complexity, or avoiding a big ball of mud</p>
<ul>
  <li>
<em>accidental complexity</em> - complexity not inherent in the problem space but arises because of the implementation</li>
  <li>an abstraction is a useful technique to hide non-important implementation details behind a façade</li>
</ul>
<h3 class="no_toc" id="evolvability">
  
  
    <a href="#evolvability" class="anchor-heading" aria-labelledby="evolvability"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Evolvability
  
  
</h3>
    
<p>make it easy for engineers to make changes to the system in the future (aka <em>extensibility</em>, <em>modifiability</em>, or <em>plasticity</em>)</p>
<h2 id="chapter-summary">
  
  
    <a href="#chapter-summary" class="anchor-heading" aria-labelledby="chapter-summary"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Chapter Summary
  
  
</h2>
    
<ul>
  <li>an application must meet various requirements to be useful
    <ul>
      <li>
<em>functional requirements</em> - what it should do, like allow data to be stored, retrieved, searched</li>
      <li>
<em>non-functional requirements</em> - general properties, like reliability, compliance, scalability, maintainability</li>
    </ul>
  </li>
  <li>
<strong>Reliability</strong> means making systems work correctly, even when faults occur. Faults can be in hardware (typically random and uncorrelated), software (bugs are typically systematic and hard to deal with), and human (who inevitability make mistakes from time to time). Fault tolerance techniques can hide certain types of faults from the end user</li>
  <li>
<strong>Scalability</strong> means having strategies for keeping performance good, even when load increases. In order to discuss scalability, we first need ways of describing load and performance quantitatively. In scalable systems, you can add processing capacity in order to remain reliable under high load.</li>
  <li>
<strong>Maintainability</strong> has many facets, but in essence it’s about making life better for the engineering and operations teams who need to work with the system. Good abstractions can help reduce complexity and make the system easier to modify and adapt for new use cases. Good operability means having good visibility into the system’s health, and having effective ways of managing it.</li>
</ul>
<h1 id="chapter-2-data-models-and-query-languages">
  
  
    <a href="#chapter-2-data-models-and-query-languages" class="anchor-heading" aria-labelledby="chapter-2-data-models-and-query-languages"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Chapter 2: Data Models and Query Languages
  
  
</h1>
    

<ul>
  <li>
    <p>Data models are perhaps the most important part of developing software – most applications are built by layering one data model on top of another, with each layer hiding the complexity of the layers below it by providing a clean data model</p>
  </li>
  <li>
    <p>Cascading levels of data models:</p>
    <ol>
      <li>as an app developer, you model the real world in terms of objects or data structures, and APIs used to manipulate those structures</li>
      <li>when you want to store that data, you use a general-purpose data model such as JSON or XML</li>
      <li>engineers who built the database software decided on ways of representing that general-purpose data model as bytes in memory, on disk, or on a network</li>
      <li>hardware engineers have figured out how to represent bytes in terms of electrical currents, pulses of light, etc.</li>
    </ol>
  </li>
</ul>
<h3 id="relational-model">
  
  
    <a href="#relational-model" class="anchor-heading" aria-labelledby="relational-model"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Relational Model
  
  
</h3>
    
<ul>
  <li>SQL based off relational model proposed by Edgar Codd in 1970</li>
  <li>data is organized in <em>relations</em> (tables in SQL) where each relation is an unordered collection of <em>tuples</em> (rows in SQL)</li>
  <li>object databases came and went in late 80’s and early 90’s</li>
  <li>XML databases appeared in early 2000’s but only have niche audience</li>
  <li>much of the current web is based on relational model</li>
  <li>
<em>impedance mismatch</em> - a borrowed electronics term which can refer to the need for a translation layer to take objects generated from object-oriented paradigms and write to a relational model
    <ul>
      <li>Object-relational mapping (ORM) frameworks like ActiveRecord, Hibernate, SQLAlchemy might reduce boilerplate code for that translation layer, but they don’t hide it completely</li>
    </ul>
  </li>
</ul>
<h3 id="document-model">
  
  
    <a href="#document-model" class="anchor-heading" aria-labelledby="document-model"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Document Model
  
  
</h3>
    
<ul>
  <li>use cases for ‘NoSQL’:
    <ul>
      <li>need for greater scalability, including for very large datasets or very high write throughput</li>
      <li>preference for free and open source software</li>
      <li>specialized query operations not well supported by relational model</li>
      <li>frustration with restrictiveness of relational schemas, and desire for more expressive and dynamic data model</li>
    </ul>
  </li>
  <li>
<em>polyglot persistence</em>: many future use cases might employ document and relational models</li>
</ul>
<h3 id="graph-model">
  
  
    <a href="#graph-model" class="anchor-heading" aria-labelledby="graph-model"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Graph Model
  
  
</h3>
    
<ul>
  <li>graph consists of two objects:
    <ul>
      <li>
<em>vertices</em> (aka <em>nodes</em> or <em>entities</em>)</li>
      <li>
<em>edges</em> (aka <em>relationships</em> or <em>arcs</em>)</li>
    </ul>
  </li>
  <li>several different implementations of graph model, including property graph, triple-stores, semantic web</li>
</ul>
<h4 class="no_toc" id="property-graph">
  
  
    <a href="#property-graph" class="anchor-heading" aria-labelledby="property-graph"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> property graph
  
  
</h4>
    
<ul>
  <li>implemented by Neo4j, Titan, and InfiniteGraph (among others)</li>
  <li>each vertex contains:
    <ul>
      <li>a unique identifier</li>
      <li>a set of outgoing edges</li>
      <li>a set of incoming edges</li>
      <li>a collection of properties (key:value pairs)</li>
    </ul>
  </li>
  <li>each edge contains:
    <ul>
      <li>a unique identifer</li>
      <li>a vertex where the edge starts (the tail vertex)</li>
      <li>a vertex where the edge ends (the head vertex)</li>
      <li>a label to describe the kind of relationship between the two vertices</li>
      <li>a collection of properties (key:value pairs)</li>
    </ul>
  </li>
  <li>think of the graph storing two relational tables, one for vertices, one for edges</li>
</ul>
<h4 class="no_toc" id="triple-stores">
  
  
    <a href="#triple-stores" class="anchor-heading" aria-labelledby="triple-stores"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> triple-stores
  
  
</h4>
    
<ul>
  <li>similar to property graphs, just describes things with different words</li>
  <li>all info stored as three-part statement - subject, predicate, object. e.g. JIM LIKES EGGS (JIM - subject, LIKES - predicate, EGGS - object)</li>
</ul>
<h5 class="no_toc" id="semantic-web">
  
  
    <a href="#semantic-web" class="anchor-heading" aria-labelledby="semantic-web"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> semantic web
  
  
</h5>
    
<ul>
  <li>while not all triple-stores are synonymous with the semantic web, they are interlinked in many minds</li>
  <li>semantic web is the idea that websites could publish machine-readable information about their sites in a consistent format to form a ‘web of data’ (note Berners-Lee constantly says there is no data layer for the internet)</li>
  <li>
<em>Resource Description Framework</em> (RDF) - is positioned as that format
    <ul>
      <li>Apache Jena popular tool for this</li>
    </ul>
  </li>
</ul>
<h3 class="no_toc" id="many-to-one-and-many-to-many-relationships">
  
  
    <a href="#many-to-one-and-many-to-many-relationships" class="anchor-heading" aria-labelledby="many-to-one-and-many-to-many-relationships"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Many-to-One and Many-to-Many Relationships
  
  
</h3>
    
<ul>
  <li>Storing standardized list of data, so you can join to that data and prevent duplication (<em>normalized</em> data)</li>
  <li>1st Normal Form (NF), 2NF, 3NF, etc have little practical difference – rule of thumb, if you are duplicating values that could be stored in one place, your schema is not normalized</li>
  <li>normalizing requires a many-to-one relationship, something not supported well with document model (support for joins is weak), meaning you need to shift that logic to application code over database model logic</li>
</ul>
<h3 id="relational-vs-document">
  
  
    <a href="#relational-vs-document" class="anchor-heading" aria-labelledby="relational-vs-document"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Relational vs Document
  
  
</h3>
    
<h4 class="no_toc" id="simpler-application-code">
  
  
    <a href="#simpler-application-code" class="anchor-heading" aria-labelledby="simpler-application-code"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> simpler application code
  
  
</h4>
    
<ul>
  <li>if your data is document-like, use document (<em>shredding</em> - relational technique of splitting a document-like structure into multiple tables, makes for complicated application code)</li>
  <li>if you need many-to-many or joins, use relational</li>
</ul>
<h4 class="no_toc" id="schema-flexibility">
  
  
    <a href="#schema-flexibility" class="anchor-heading" aria-labelledby="schema-flexibility"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> schema flexibility
  
  
</h4>
    
<ul>
  <li>
<em>schema-on-write</em> (relational): structure of data is explicit and database ensures all data conforms to it</li>
  <li>
<em>schema-on-read</em> (document): structure of data is implicit and only interpreted when data is read
    <blockquote>
      <p>NOTE: <code class="language-plaintext highlighter-rouge">ALTER TABLE</code> typically fast except for MySQL, where the entire table is copied</p>
    </blockquote>
  </li>
</ul>
<h4 class="no_toc" id="data-locality">
  
  
    <a href="#data-locality" class="anchor-heading" aria-labelledby="data-locality"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> data locality
  
  
</h4>
    
<ul>
  <li>if joins aren’t required for your document, then there is a performance advantage to all data in a single document (called <em>storage locality</em>)</li>
  <li>some relational databases group related data together to achieve storage locality
    <ul>
      <li>Google’s Spanner (allows schema to declare table’s rows interleaved (nested) with a parents)</li>
      <li>Oracle through <em>multi-table index cluster tables</em>
</li>
      <li>Bigtable (Cassandra and HBase) through <em>column-family</em>
</li>
    </ul>
  </li>
</ul>
<h4 class="no_toc" id="convergence">
  
  
    <a href="#convergence" class="anchor-heading" aria-labelledby="convergence"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> convergence
  
  
</h4>
    
<p>Many data systems support multiple models.</p>
<ul>
  <li>many relational databases support JSON (PostGreSQL 9.3+, MySQL 5.7+)</li>
  <li>many relational databases support XML (other than MySQL)</li>
</ul>
<h3 id="query-languages">
  
  
    <a href="#query-languages" class="anchor-heading" aria-labelledby="query-languages"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Query Languages
  
  
</h3>
    
<h4 class="no_toc" id="sql">
  
  
    <a href="#sql" class="anchor-heading" aria-labelledby="sql"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> SQL
  
  
</h4>
    
<ul>
  <li>SQL is a <em>declarative</em> language which follows the structure of relational algebra closely</li>
  <li>other declarative languages examples: XSL, CSS</li>
  <li>
<em>imperative</em> languages tell the computer to perform operations in order (most programming languages)</li>
  <li>declarative languages lend themselves to parallel execution</li>
</ul>
<h4 class="no_toc" id="mapreduce-querying">
  
  
    <a href="#mapreduce-querying" class="anchor-heading" aria-labelledby="mapreduce-querying"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> MapReduce Querying
  
  
</h4>
    
<ul>
  <li>programming model for processing large amounts of data across multiple machines created by Google</li>
  <li>you specify two functions – <code class="language-plaintext highlighter-rouge">map</code> (aka <code class="language-plaintext highlighter-rouge">collect</code>), and a <code class="language-plaintext highlighter-rouge">reduce</code> (aka <code class="language-plaintext highlighter-rouge">fold</code> or <code class="language-plaintext highlighter-rouge">inject</code>). Below is MapReduce implemented in MongoDB:</li>
  <li>MongoDB allows you to embed javascript in a MapReduce query:</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><div class="table-wrapper"><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td>
<td class="rouge-code"><pre><span class="nx">db</span><span class="p">.</span><span class="nx">observations</span><span class="p">.</span><span class="nx">mapReduce</span><span class="p">(</span>
  <span class="kd">function</span> <span class="nx">map</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// this function returns a key and a value to be passed to</span>
    <span class="c1">// the reduce function, and must be pure (no side effects)</span>
    <span class="kd">var</span> <span class="nx">year</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">observationTimestamp</span><span class="p">.</span><span class="nx">getFullYear</span><span class="p">();</span>
    <span class="kd">var</span> <span class="nx">month</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">observationTimestamp</span><span class="p">.</span><span class="nx">getMonth</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="nx">emit</span><span class="p">(</span><span class="nx">year</span> <span class="o">+</span> <span class="dl">"</span><span class="s2">-</span><span class="dl">"</span> <span class="o">+</span> <span class="nx">month</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">numAnimals</span><span class="p">);</span>
  <span class="p">},</span>
  <span class="kd">function</span> <span class="nx">reduce</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">values</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// this pure function takes the key and values from map</span>
    <span class="k">return</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">sum</span><span class="p">(</span><span class="nx">values</span><span class="p">);</span>
  <span class="p">},</span>
  <span class="p">{</span>
    <span class="na">query</span><span class="p">:</span> <span class="p">{</span><span class="na">family</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Sharks</span><span class="dl">"</span><span class="p">},</span>
    <span class="na">out</span><span class="p">:</span> <span class="dl">"</span><span class="s2">monthlySharkReport</span><span class="dl">"</span>
  <span class="p">}</span>
<span class="p">)</span>
</pre></td>
</tr></tbody></table></div></code></pre></div></div>
<h4 class="no_toc" id="cypher">
  
  
    <a href="#cypher" class="anchor-heading" aria-labelledby="cypher"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Cypher
  
  
</h4>
    
<ul>
  <li>declarative language implemented by Neo4j and used to query property graphs</li>
</ul>
<h4 class="no_toc" id="querying-graph-models-with-sql">
  
  
    <a href="#querying-graph-models-with-sql" class="anchor-heading" aria-labelledby="querying-graph-models-with-sql"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Querying Graph Models with SQL
  
  
</h4>
    
<ul>
  <li>you can query graph models in SQL, it is just extremely verbose, and relies on a <em>recursive common table expression</em> e.g. <code class="language-plaintext highlighter-rouge">WITH RECURSIVE</code>
</li>
  <li>
<em>common table expressions</em> - temporary data set returned by a query, which is then used by another query. It’s temporary because the result is not stored anywhere; it exists only when the query is run – e.g. <code class="language-plaintext highlighter-rouge">WITH expression_name AS (CTE definition)</code>
</li>
</ul>
<h4 class="no_toc" id="sparql">
  
  
    <a href="#sparql" class="anchor-heading" aria-labelledby="sparql"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> SPARQL
  
  
</h4>
    
<ul>
  <li>query language for triple-stores using RDF data model</li>
  <li>similar to Cypher (Cypher borrows its pattern matching from SPARQL)</li>
</ul>
<h4 class="no_toc" id="datalog">
  
  
    <a href="#datalog" class="anchor-heading" aria-labelledby="datalog"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Datalog
  
  
</h4>
    
<ul>
  <li>predates SPARQL</li>
  <li>is a subset of Prolog</li>
  <li>need to define rules at outset, and while it might be harder for one-off queries, rules are reusable and Datalog might fit use case if data is complex</li>
</ul>
<h2 id="chapter-summary-1">
  
  
    <a href="#chapter-summary-1" class="anchor-heading" aria-labelledby="chapter-summary-1"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Chapter Summary
  
  
</h2>
    
<ul>
  <li>Historically, data started out being represented as one big tree (the hierarchical model), but that wasn’t good for representing many-to-many relationships, so the relational model was invented to solve that problem. More recently, developers found that some apps don’t fit well within the relational model either. New nonrelational “NoSQL” datastores have diverged in two main directions
    <ol>
      <li>
<em>Document databases</em> target use cases where data comes in self-contained documents and relationships between one document and another are rare.</li>
      <li>
<em>Graph databases</em> go in the opposite direction, targeting use cases where anything is potentially related to everything.</li>
    </ol>
  </li>
  <li>All three models (document, relational, and graph) are widely used. Each is good in its domain. One model can be emulated in terms of another model (e.g. graph data can be represented in a relational db), but the result is often awkward. There is no single one-size-fits-all solution</li>
  <li>graph databases and document databases don’t typically enforce schema for data they store, however, application most likely still assumes that data has a certain structure. just a question of whether the schema is explicit (schema-on-write) or implicit (schema-on-read)</li>
  <li>each model comes with its own query language or framework, e.g. SQL, MapReduce, MongoDB’s aggregation pipeline, Cypher, SPARQL, Datalog</li>
</ul>
<h1 id="chapter-3-storage-and-retrieval">
  
  
    <a href="#chapter-3-storage-and-retrieval" class="anchor-heading" aria-labelledby="chapter-3-storage-and-retrieval"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Chapter 3: Storage and Retrieval
  
  
</h1>
    

<p>at a fundamental level, a database needs to do two things:</p>
<ol>
  <li>when you give it data it should store the data</li>
  <li>when you ask it later it should give the data back to you</li>
</ol>
<h2 class="no_toc" id="log-structured-storage">
  
  
    <a href="#log-structured-storage" class="anchor-heading" aria-labelledby="log-structured-storage"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Log-structured storage
  
  
</h2>
    
<ul>
  <li>many databases internally use a log, or append only sequence of records, to store data (different from application logs, which are typically text files emitted by an application to describe what is happening)
    <blockquote>
      <p><em>log</em> used here is different than a machine-generated output explaining what is happening. log here means append only sequence of records</p>
    </blockquote>
  </li>
</ul>
<h3 id="indexes">
  
  
    <a href="#indexes" class="anchor-heading" aria-labelledby="indexes"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Indexes
  
  
</h3>
    
<ul>
  <li>an <em>additional structure</em> used to efficiently find data within a database</li>
  <li>keep some additional metadata on the side which acts a signpost to help you locate the data you want</li>
  <li>speeds up read performance but degrades write performance (typically because index needs to be updated after every write)</li>
</ul>
<h4 class="no_toc" id="hash-indexes">
  
  
    <a href="#hash-indexes" class="anchor-heading" aria-labelledby="hash-indexes"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Hash Indexes
  
  
</h4>
    
<ul>
  <li>simple index of key:value pairs stored in a hash map/dictionary on disk, where each key is associated with a byte offset to lookup the value on disk</li>
  <li>Bitcask, the default storage engine for Riak, does this</li>
  <li>this sort of use case is well-suited for frequent updates to values and where the hash map can fit in memory</li>
  <li>important things to consider for this implementation:
    <ul>
      <li>
<strong>file format</strong>: binary format that first encodes the length of string in bytes then the raw string (without needing to escape chars)</li>
      <li>
<strong>deleting records</strong>: if you want to delete a record, you need to append a special delete record (sometimes called a tombstone) to signal during compaction merge to remove the record</li>
      <li>
<strong>crash recovery</strong>: since the hash map is in memory, restarts mean you lose the hash map. you can store version on disk to warm start the hash map</li>
      <li>
<strong>partially written records</strong>: crashes can happen at any time, even partially through writes. Bitcask uses checksums to ignore corrupted parts of log</li>
      <li>
<strong>concurrency control</strong>: since writes are sequential append only, its common to only have a single writer. Data files are append only and immutable, so they can be read concurrently</li>
    </ul>
  </li>
</ul>
<h5 class="no_toc" id="segment-files">
  
  
    <a href="#segment-files" class="anchor-heading" aria-labelledby="segment-files"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> segment files
  
  
</h5>
    
<ul>
  <li>since the log is an append-only structure, we need break it up into <em>segment files</em> to prevent running out of space</li>
  <li>after a segment file reaches a certain size, we can create a new one to write to, then perform <em>compaction</em> on the older segment files, meaning, throwing away duplicate keys in the log and keeping only the most recent update
    <ul>
      <li>older segment files are merged in the background then swapped without interruption to writes</li>
    </ul>
  </li>
</ul>
<h4 class="no_toc" id="sstables">
  
  
    <a href="#sstables" class="anchor-heading" aria-labelledby="sstables"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> SSTables
  
  
</h4>
    
<ul>
  <li>
<strong>Sorted String Table</strong> (SSTable) - takes the idea for hash indexes, but requires that segment files be sorted in order by key. also requires that each key only appears once in each merged segment table (because in order to do compaction, we need to mergesort, which relies on uniqueness of keys when comparing one file to another)</li>
  <li>keys duplicated across segment files don’t matter, since most recent segment contains most up to date value per key</li>
  <li>your in-memory hash index can be sparse, because keys are sorted and so easy to scan (typically one index per every few kilobytes is sufficient)</li>
  <li>you can compress blocks and then just point the index at a block, saving disk space and I/O</li>
</ul>
<h5 class="no_toc" id="lsm-trees">
  
  
    <a href="#lsm-trees" class="anchor-heading" aria-labelledby="lsm-trees"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> LSM-Trees
  
  
</h5>
    
<ul>
  <li>described in Patrick O’Neil et al <em>Log-Structured Merge-Tree</em> or LSM-tree</li>
  <li>
<em>memtable</em> and SSTable introduced by Google’s Bigtable paper</li>
  <li>how do we maintain sorted order? much easier in memory than on disk
    <ul>
      <li>write comes in, add to a balanced tree data structure (e.g. a red-black tree) - this is typically called a <em>memtable</em>
</li>
      <li>when <em>memtable</em> is larger than a threshold, write that <em>memtable</em> as an SSTable file to disk. start new <em>memtable</em> while old is being written to disk</li>
      <li>to serve a read request, first check <em>memtable</em>, then first segment file, then second, etc.</li>
      <li>from time to time, run a merging and compaction process for older segment files</li>
      <li>maintain an append only log on disk that holds all writes, to recover the <em>memtable</em> in case of crash (you can delete after current <em>memtable</em> is written to disk)</li>
    </ul>
  </li>
</ul>
<h4 class="no_toc" id="b-trees">
  
  
    <a href="#b-trees" class="anchor-heading" aria-labelledby="b-trees"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> B-Trees
  
  
</h4>
    
<ul>
  <li>keeps indexes sorted by value, but instead of storing database in segment files, B-Trees store database in fixed size <em>blocks</em> or <em>pages</em>, which corresponds more closely to underlying hardware</li>
  <li>you start at the root of the tree. each page contains references (like pointers but on disk) to child pages until you get to a page of individual keys (a leaf page), which either contains the value or references to the page where the value can be found</li>
  <li>number of references to child pages called the <em>branching factor</em>
</li>
  <li>trees are balanced, so traversal is always O(log <em>n</em>) – most databases can fit into a B-tree that is three or four levels deep (e.g. a four-level tree of 4 KB pages with a branching factor of 500 can store 256 TB)</li>
</ul>
<h5 class="no_toc" id="reliability-1">
  
  
    <a href="#reliability-1" class="anchor-heading" aria-labelledby="reliability-1"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Reliability
  
  
</h5>
    
<ul>
  <li>many B-tree impl. use <em>write-ahead logs</em> (WAL), aka <em>redo logs</em>, to persist all writes to the database in an append only log before it can be applied to pages</li>
</ul>
<h4 class="no_toc" id="b-trees-vs-lsm-trees">
  
  
    <a href="#b-trees-vs-lsm-trees" class="anchor-heading" aria-labelledby="b-trees-vs-lsm-trees"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> B-Trees vs LSM-Trees
  
  
</h4>
    
<ul>
  <li>B-Trees need to write data twice, once to the write-ahead log and once to page</li>
  <li>Log-structured indexes might write data multiple times due to repeated compaction and merging (write amplification) and is particularly concerning for SSDs, which can only overwrite blocks a limited amount of times before wearing out</li>
  <li>LSM-Trees typically able to sustain higher write throughput because they often have lower write amplification</li>
  <li>B-Trees have keys that exist exactly one place in index, which is good for databases that want strong transactional semantics via transaction isolation and locks</li>
</ul>
<h4 class="no_toc" id="secondary-indexes">
  
  
    <a href="#secondary-indexes" class="anchor-heading" aria-labelledby="secondary-indexes"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Secondary Indexes
  
  
</h4>
    
<ul>
  <li>both log-structured and B-Trees can work as secondary indexes in addition to a primary key index. These secondary indexes don’t need to be unique (unless you add that constraint)</li>
</ul>
<h4 class="no_toc" id="storing-values-within-the-index">
  
  
    <a href="#storing-values-within-the-index" class="anchor-heading" aria-labelledby="storing-values-within-the-index"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Storing values within the index
  
  
</h4>
    
<ul>
  <li>the value of the index might be an actual row, or it might be a reference to the row, typically stored in a <em>heap file</em> – data in these heap files are not stored in any particular order</li>
  <li>updating a value in a heap file can be efficient by overwriting the data in place (assuming the data is the same length)</li>
  <li>
<em>clustered index</em> - storing the row directly in the index, and secondary indexes just refer to the primary key</li>
  <li>a compromise between clustered and non-clustered is a <em>covering index</em>, or <em>index with included columns</em>, which stores some of the tables columns within an index, allowing queries to be ‘covered’ or answered by an index alone</li>
</ul>
<h4 class="no_toc" id="multi-column-indexes">
  
  
    <a href="#multi-column-indexes" class="anchor-heading" aria-labelledby="multi-column-indexes"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Multi-column indexes
  
  
</h4>
    
<ul>
  <li>concatenated indexes used to store indexes for multiple columns, which is good for searching full index combinations, but not individual columns after the primary key</li>
  <li>multi-dimensional indexes are a good way to query several columns at once, especially for geospatial data. R-Trees are typically used instead of B-Trees</li>
</ul>
<h4 class="no_toc" id="full-text-search-and-fuzzy-indexes">
  
  
    <a href="#full-text-search-and-fuzzy-indexes" class="anchor-heading" aria-labelledby="full-text-search-and-fuzzy-indexes"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Full-text search and fuzzy indexes
  
  
</h4>
    
<ul>
  <li>Lucene is able to search for words within a certain edit distance (edit distance meaning when 1 letter has been added, removed, or replaced)</li>
  <li>
<em>Levenshtein distance</em> - used to figure out amount of edits required to go from one word to another</li>
</ul>
<h4 class="no_toc" id="in-memory-databases">
  
  
    <a href="#in-memory-databases" class="anchor-heading" aria-labelledby="in-memory-databases"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> In memory databases
  
  
</h4>
    
<ul>
  <li>we typically use disks because they are durable and cost less per gigabyte than RAM (the second argument is becoming less relevant)</li>
  <li>
<strong>Memcached</strong> - an entirely in memory cache (lost if restarted)</li>
  <li>other in-memory databases aim for more durability, writing log of changes to disk, writing periodic snapshots, etc.</li>
  <li>
<strong>VoltDB</strong>, <strong>MemSQL</strong>, and <strong>Oracle TimesTen</strong> are relational in-memory databases</li>
  <li>anti-caching approach is a way around working with datasets larger than memory, by persisting data to disk when out of memory, and bringing back into memory when used (this is similar to virtual memory and swap files at OS level)</li>
  <li>new area of research - <em>nonvolatile memory</em> (NVM); still in infancy</li>
</ul>
<h3 id="transactions-vs-analytics">
  
  
    <a href="#transactions-vs-analytics" class="anchor-heading" aria-labelledby="transactions-vs-analytics"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Transactions vs Analytics
  
  
</h3>
    

<div class="table-wrapper"><table>
  <thead>
    <tr>
      <th>Property</th>
      <th>Transaction processing systems (OLTP)</th>
      <th>Analytics systems (OLAP)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Main read pattern</td>
      <td>small number of records per query, fetched by key</td>
      <td>aggregate over large number of records</td>
    </tr>
    <tr>
      <td>Main write pattern</td>
      <td>Random-access, low-latency writes from user input</td>
      <td>Bulk import (ETL) or event stream</td>
    </tr>
    <tr>
      <td>Primarily used by</td>
      <td>End user/customer via web application</td>
      <td>Internal analyst, for decision support</td>
    </tr>
    <tr>
      <td>What data represents</td>
      <td>Latest state of data (current point in time)</td>
      <td>History of events that happened over time</td>
    </tr>
    <tr>
      <td>Dataset size</td>
      <td>Gigabytes to terabytes</td>
      <td>Terabytes to petabytes</td>
    </tr>
  </tbody>
</table></div>
<h3 id="data-warehouses-and-column-oriented-storage">
  
  
    <a href="#data-warehouses-and-column-oriented-storage" class="anchor-heading" aria-labelledby="data-warehouses-and-column-oriented-storage"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Data Warehouses and Column-Oriented Storage
  
  
</h3>
    
<ul>
  <li>you store data in an OLAP data warehouse as it will be insulated from live transaction processing and queries won’t affect live customer-facing systems</li>
  <li>typically perform Extract-Transform-Load (ETL) operations to populate the database</li>
  <li>Data warehouses typically sell their systems under expensive commercial licenses (e.g. Amazon RedShift is a host version of ParAccel)</li>
  <li>Some are based on the ideas from Google’s Dremel</li>
  <li>many data warehouses can have hundreds of columns</li>
  <li>The typical use case for OLAP queries are only accessing a small amount of many columns – unlike OLTP systems which are <em>row-oriented storage</em>, meaning that a row is stored in contiguous bytes on disks, OLAP systems are <em>column-oriented storage</em>, which stores a column in contiguous bytes.</li>
</ul>
<h5 class="no_toc" id="star-and-snowflake-schema">
  
  
    <a href="#star-and-snowflake-schema" class="anchor-heading" aria-labelledby="star-and-snowflake-schema"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Star and Snowflake Schema
  
  
</h5>
    
<ul>
  <li>many data warehouses use <em>star schema</em> as their data model (known as <em>dimensional modeling</em>)</li>
  <li>at the center of the schema is a <em>fact table</em>, most often representing a particular event</li>
  <li>some of the columns are attributes of the event, while others are foreign key references to other tables called <em>dimension tables</em>, which typically represent the who, what, where, when, how, and why of the event</li>
  <li>
<em>snowflake schema</em> - a variation of the star schema, but dimensions are broken even further into sub-dimensions</li>
</ul>
<h5 class="no_toc" id="column-compression">
  
  
    <a href="#column-compression" class="anchor-heading" aria-labelledby="column-compression"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Column Compression
  
  
</h5>
    
<ul>
  <li>since there are far less distinct values in a column than there are rows, we can compress this data. a popular method is <em>bitmap encoding</em>, which details all the unique values in a column, then encodes an array of 1s and 0s for whether a row contains that value, which creates sparse data sets, which can be compressed more easily by encoding run length (how many 1s or 0s in a row)</li>
</ul>
<h5 class="no_toc" id="vectorized-processing">
  
  
    <a href="#vectorized-processing" class="anchor-heading" aria-labelledby="vectorized-processing"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Vectorized Processing
  
  
</h5>
    
<ul>
  <li>the query engine can take a chunk of compressed column data that fits in the CPU’s L1 cache, and iterate through in a tight loop (no function calls) much more quickly than if many function calls are required, e.g. to type-cast data formats</li>
</ul>
<h5 class="no_toc" id="materialized-views">
  
  
    <a href="#materialized-views" class="anchor-heading" aria-labelledby="materialized-views"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Materialized Views
  
  
</h5>
    
<ul>
  <li>for expensive queries (like aggregation functions), it might make sense to actually store the results in a table. materialized views differ from regular views (which are just shorthand for queries) because they are an actual table stored on disk, and they need to be recomputed when the underlying data changes</li>
  <li>a special use case is a <em>data cube</em>, which is a grid of aggregates based on various dimensions (e.g. product sales for a given day, also rolled to a total)</li>
</ul>
<h2 id="chapter-summary-2">
  
  
    <a href="#chapter-summary-2" class="anchor-heading" aria-labelledby="chapter-summary-2"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Chapter Summary
  
  
</h2>
    
<ul>
  <li>storage engines fall into two broad categories
    <ol>
      <li>optimized for transaction processing (OLTP)</li>
      <li>optimized for analytics processing (OLAP)</li>
    </ol>
  </li>
  <li>OLTP systems are typically user-facing, which means they see a huge volume of requests. In order to handle the load, applications usually only touch a small number of records in each query. The application requests records using some kind of key, and the storage engine uses an index to find the data for the requests key. Disk seek time is often a bottleneck.</li>
  <li>Data warehouses and similar analytics used by business analysts, not end users. They handle much lower volume of queries, and each query is demanding, requiring many million records to be scanned in short time. Disk bandwith is often bottleneck</li>
  <li>On storage engine side, there are two main schools of thought:
    <ol>
      <li>log-structured: only permits appending to files and deleting obsolete files, but never updates a file that has been written. e.g. Bitcask, SSTables, LSM-Trees, LevelDB, Cassandra, HBase, Lucene, etc</li>
      <li>update-in-place: treats the disk as a set of fixed-size pages that can be overwritten. e.g. B-Trees</li>
    </ol>
  </li>
  <li>log-structured storage engines are comparatively new — the key is they systematically turn random-access writes into sequential writes which enables higher write throughput</li>
</ul>
<h1 id="chapter-4-encoding-and-evolution">
  
  
    <a href="#chapter-4-encoding-and-evolution" class="anchor-heading" aria-labelledby="chapter-4-encoding-and-evolution"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Chapter 4: Encoding and Evolution
  
  
</h1>
    
<h2 id="formats-for-encoding-data">
  
  
    <a href="#formats-for-encoding-data" class="anchor-heading" aria-labelledby="formats-for-encoding-data"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Formats for Encoding Data
  
  
</h2>
    
<ul>
  <li>Programs typically work with data in two ways:
    <ol>
      <li>in memory: kept in objects (list, array, struct, hash table, etc.) and efficiently accessed and manipulated by CPU (typically via pointers)</li>
      <li>out of memory: you need to encode data into a self-contained sequence of bytes to write to file or send over network, etc</li>
    </ol>
  </li>
  <li>
<strong>encoding</strong> - the translation of in-memory representation to byte sequence (aka <em>serialization</em> or <em>marshalling</em>), and the opposite action is <em>decoding</em> (aka <em>parsing</em>, <em>deserialization</em>, <em>unmarshalling</em>)</li>
</ul>
<h3 class="no_toc" id="language-specific-formats">
  
  
    <a href="#language-specific-formats" class="anchor-heading" aria-labelledby="language-specific-formats"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Language-Specific Formats
  
  
</h3>
    
<ul>
  <li>many languages have built-in support for encoding in-memory objects to byte sequences:
    <ul>
      <li>
<code class="language-plaintext highlighter-rouge">java.io.Serializable</code> for Java</li>
      <li>‘Marshal` for Ruby</li>
      <li>
<code class="language-plaintext highlighter-rouge">pickle</code> for python</li>
    </ul>
  </li>
  <li>this languages bind you to the programming language, and instantiate arbitrary classes or execute arbitrary code, which is a security risk</li>
</ul>
<h3 class="no_toc" id="json-xml-and-binary-variants">
  
  
    <a href="#json-xml-and-binary-variants" class="anchor-heading" aria-labelledby="json-xml-and-binary-variants"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> JSON, XML, and Binary Variants
  
  
</h3>
    
<ul>
  <li>JSON, XML, and CSV are textual formats and will remain valuable especially as interchange formats between organizations, but there are limitations:
    <ul>
      <li>
<strong>ambiguity around encoding numbers</strong> - in XML and CSV, you can’t distinguish between a number a string that happens to consist of digits. JSON doesn’t distinguish integers and floats, and doesn’t distinguish precision, which is a problem with large numbers (&gt; 2<sup>53</sup>)</li>
      <li>
<strong>binary strings</strong> - JSON and XML have good support for Unicode character strings, but not binary strings – binary strings are typically encoded as text using Base64, which is hacky and increases data footprint by 33%</li>
      <li>
<strong>schema support</strong> - schema support is ubiquitous for XML, but used less often for JSON, and there is no schema support for CSV. Schema languages are powerful but complicated to learn</li>
    </ul>
  </li>
  <li>Binary variants for JSON - BSON, BJSON, UBJSON, BISON, Smile, etc</li>
  <li>Binary variants for XML - WBXML, Fast Infoset, etc</li>
</ul>
<h3 class="no_toc" id="thrift-and-protocol-buffers">
  
  
    <a href="#thrift-and-protocol-buffers" class="anchor-heading" aria-labelledby="thrift-and-protocol-buffers"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Thrift and Protocol Buffers
  
  
</h3>
    
<ul>
  <li>binary encoding libraries that encode object name and type using a schema</li>
  <li>Google invented Thrift, Facebook invented protobuf</li>
  <li>Thrift has two encoding formats, BinaryProtocol and CompactProtocol</li>
</ul>
<h3 class="no_toc" id="avro">
  
  
    <a href="#avro" class="anchor-heading" aria-labelledby="avro"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Avro
  
  
</h3>
    
<ul>
  <li>started in 2009 as a subproject of Hadoop</li>
  <li>has two schema languages
    <ul>
      <li>Avro interface domain language (IDL) for human editing</li>
      <li>JSON for more easy machine reading</li>
    </ul>
  </li>
  <li>
    <p>data type isn’t encoded in the binary, so you need to read the data along with the schema to determine data type, meaning you need to decode with the exact same schema used to write the data</p>
  </li>
  <li>
<strong>backward and forward compatibility</strong>:
    <ul>
      <li>writer and reader schema don’t need to be the same, just compatible</li>
      <li>
<strong>writer’s schema</strong> - schema used to write data</li>
      <li>
<strong>reader’s schema</strong> - schema used to read data</li>
      <li>if the code reading the data encounters a field that appears in the writer’s schema but not in the reader’s schema, it is ignored</li>
      <li>if the code reading the data expects some field but the writer’s schema does not contain a field of that name, it is filled in with a default value declared in the reader’s schema</li>
    </ul>
  </li>
  <li>schema can be:
    <ul>
      <li>declared at the beginning of a large container file with many records</li>
      <li>referenced by a version number stored elsewhere at the beginning of a record</li>
      <li>negotiated on connection setup over a network via something like the Avro RPC protocol</li>
    </ul>
  </li>
  <li>Thrift and Protocol Buffer rely on code generation, which is good for static typed languages but less good for dynamic typed languages</li>
  <li>Avro provides optional code generation because it is <em>self-describing</em>, containing all necessary metadata
    <ul>
      <li>this is particularly useful for dynamically typed data processing languages like Apache Pig</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>Many of these encodings share a lot with ASN.1, a schema definition language. It’s binary encoding (DER) is still used to encode SSL certs (X.509)</p>
</blockquote>

<ul>
  <li>Binary encodings have a few nice properties over JSON, XML, &amp; CSV
    <ul>
      <li>much more compact</li>
      <li>schema is a valuable document, and since it is required for reading you know it’s up to date</li>
      <li>keeping a database of schemas allows you to check forward and backward compatibility</li>
      <li>for static typed languages, ability to generate code from schemas is useful</li>
    </ul>
  </li>
</ul>
<h2 id="modes-of-dataflow">
  
  
    <a href="#modes-of-dataflow" class="anchor-heading" aria-labelledby="modes-of-dataflow"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Modes of Dataflow
  
  
</h2>
    
<h3 id="dataflow-through-databases">
  
  
    <a href="#dataflow-through-databases" class="anchor-heading" aria-labelledby="dataflow-through-databases"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Dataflow through Databases
  
  
</h3>
    
<ul>
  <li>process that writes to the database encodes the data, process that reads from the database decodes it</li>
  <li>several processes might be accessing a database at the same time, so some might be running newer code and some older, so forward compatibility is important</li>
  <li><em>data outlives code</em></li>
  <li>you can rewrite data into a new schema (<em>migration</em>) but it is expensive and time consuming on larger datasets</li>
  <li>schema evolution allows the entire database to appear as if it was encoded with a single schema, even though underlying records were written with various versions</li>
  <li>when you do a data dump, it is written in one go and is immutable afterwards, so object containers like Avro might be a good fit, or analytics-friendly column-oriented format such as Parquet</li>
</ul>
<h3 id="dataflow-through-services-rest-and-rpc">
  
  
    <a href="#dataflow-through-services-rest-and-rpc" class="anchor-heading" aria-labelledby="dataflow-through-services-rest-and-rpc"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Dataflow through Services: REST and RPC
  
  
</h3>
    
<ul>
  <li>when two processes need to communicate over a network, the most common way is to have two roles: <em>clients</em> &amp; <em>servers</em> – servers expose an API and the clients connet to the servers to make requests to that API as a <em>service</em>
</li>
  <li>web -&gt; clients (web browsers) make requests to web servers, send <code class="language-plaintext highlighter-rouge">GET</code> requests to download HTML, CSS, JS, etc, and send <code class="language-plaintext highlighter-rouge">POST</code> requests to submit data to server</li>
  <li>native app also make network requests</li>
  <li>a client-side JS app running in browser can use XMLHttpRequest to become an HTTP client (<em>Ajax</em>)</li>
  <li>
<em>service-oriented architecture</em> (SOA) or <em>microservice architecture</em> – to decompose a larger app into smaller services
    <ul>
      <li>key idea is to make app easier to change and maintain by making services independently deployable and evolvable</li>
    </ul>
  </li>
</ul>
<h4 class="no_toc" id="web-services">
  
  
    <a href="#web-services" class="anchor-heading" aria-labelledby="web-services"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Web Services
  
  
</h4>
    
<ul>
  <li>when HTTP is used for the underlying protocol of talking to the service, it is called a <em>web service</em>
</li>
  <li>two popular approaches: REST and SOAP, which are almost opposite in terms of philosophy</li>
</ul>
<h5 class="no_toc" id="rest">
  
  
    <a href="#rest" class="anchor-heading" aria-labelledby="rest"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> REST
  
  
</h5>
    
<ul>
  <li>REST is not a protocol but a design philosophy
    <ul>
      <li>simple data formats</li>
      <li>URLs for identifying resources</li>
      <li>using HTTP for cache control, authentication, and content type negotiations</li>
    </ul>
  </li>
  <li>an API designed according to REST principles is <em>RESTful</em>
</li>
  <li>definition format such as OpenAPI (aka Swagger) can be used to describe RESTful APIs and produce documentation</li>
</ul>
<h5 class="no_toc" id="soap">
  
  
    <a href="#soap" class="anchor-heading" aria-labelledby="soap"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> SOAP
  
  
</h5>
    
<ul>
  <li>XML based protocol for making API requests, most commonly used over HTTP but comes with a complex plethora of related standards (<em>web service framework</em>, aka <em>WS-*</em>)</li>
  <li>described using Web Services Description Language (WSDL), which is not designed to be human-readable</li>
  <li>ostensibly standardized, but interoperability between different vendor impl. might cause problems</li>
</ul>
<h4 class="no_toc" id="rpc">
  
  
    <a href="#rpc" class="anchor-heading" aria-labelledby="rpc"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> RPC
  
  
</h4>
    
<ul>
  <li>many implementations of making API calls over network, all based on <em>remote procedure call</em> (RPC)
    <ul>
      <li>Enterprise JavaBeans (EJB) and Java’s Remote Method Invocation (RMI) - limited to Java</li>
      <li>Distributed Component Object Model (DCOM) limited to Microsoft platforms</li>
      <li>Common Object Request Broker Architecture (CORBA) overly complex and neither forward or backward compatible</li>
    </ul>
  </li>
  <li>RPC tries to make calling a remote service look the same as calling a function within programming language (called <em>location transparency</em>)</li>
  <li>this approach is flawed because:
    <ul>
      <li>a local function call either succeeds or fails, but a network request is unpredictable</li>
      <li>a local function returns a result or throws an exception, but a network request might timeout</li>
      <li>there is no inherent mechanism for idempotence with network calls</li>
      <li>network calls have variable execution time</li>
      <li>local function calls allow you to pass pointers, but network calls require those parameters to be encoded into a sequence of bytes</li>
      <li>the client might be in a different programming language, causing the need for a translation of data types</li>
    </ul>
  </li>
</ul>
<h3 id="dataflow-though-async-messages">
  
  
    <a href="#dataflow-though-async-messages" class="anchor-heading" aria-labelledby="dataflow-though-async-messages"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Dataflow though async messages
  
  
</h3>
    
<ul>
  <li>async message-passing systems are somewhere between RPC and databases</li>
  <li>a client’s request (<em>message</em>) is passed to another process with low latency, to an intermediary called a <em>message broker</em>, or <em>message queue</em>
</li>
  <li>using a message queue has advantages
    <ul>
      <li>it can act as a buffer if recipient is overloaded or unavailable</li>
      <li>it can automatically redeliver messages to a crashed process so nothing is lost</li>
      <li>it avoid sender needing to know IP and port of recipient, where virtual machines come and go</li>
      <li>it allows one message to be sent to several recipients</li>
      <li>it logically decouples sender from recipient</li>
    </ul>
  </li>
  <li>In the past, message brokers were dominated by commercial enterprise (TIBCO, IBM WebSphere, webMethods), but more recently, open source impl. like RabbitMQ, ActiveMQ, HornetQ, NATS, and Apache Kafka are populate</li>
  <li>They typically work like this: one process (producer) sends a message to a named queue or topic, and the broker ensures that the message is delivered to one or more consumers or subscribers to that queue or topic – there can be many producers and consumers</li>
</ul>
<h4 class="no_toc" id="distributed-actor-frameworks">
  
  
    <a href="#distributed-actor-frameworks" class="anchor-heading" aria-labelledby="distributed-actor-frameworks"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Distributed actor frameworks
  
  
</h4>
    
<ul>
  <li>
<em>actor model</em> - programming model for concurrency in a single process. logic is encapsulated in an actor, and that sends async messages</li>
</ul>
<h2 id="chapter-summary-3">
  
  
    <a href="#chapter-summary-3" class="anchor-heading" aria-labelledby="chapter-summary-3"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Chapter Summary
  
  
</h2>
    
<ul>
  <li>many services need to support rolling upgrades, where a new version of a service is gradually deployed to a few nodes at a time</li>
  <li>rolling upgrades allow a new version of a service to be released without downtime (thus encouraging frequent small releases over rare big releases) and make deployments less risky – these properties are hugely important for evolvability</li>
  <li>during rolling upgrades (or for various other reasons) we must assume that different nodes are running different versions of our application’s code – it is important that all data flowing around the system is encoded in a way that provides backward (new code can read old data) and forward (old code can read new data) compatibility</li>
  <li>there are several data encoding formats
    <ul>
      <li>programming language-specific encodings are restricted to a single programming language and often fail to provide forward and backward compatibility</li>
      <li>textual formats like JSON, XML, and CSV are widespread, and their compatibility depends on how you use them – they have optional schema languages, which are sometimes helpful and sometimes a hindrance, and these formats are sometimes vague about datatypes, so you have to be careful with things like numbers and binary strings</li>
      <li>binary schema-driven formats like Thrift, Protocol Buffers, and Avro allow compact, efficient encoding with clearly defined forward and backward compatible semantics – these schemas can be useful for documentation and code generation in statically typed languages</li>
    </ul>
  </li>
  <li>there are several modes of dataflow
    <ul>
      <li>databases, where the process writing to the database encodes the data and the process reading from the database decodes it</li>
      <li>RPC and REST APIs, where the client encodes a request, the server decodes the request and encodes a response, and the client finally decodes the response</li>
      <li>asynchronous message passing (using message brokers or actors) where nodes communicate by sending each other messages that are encoded by the sender and decoded by the recipient</li>
    </ul>
  </li>
</ul>
<h1 id="chapter-5-replication">
  
  
    <a href="#chapter-5-replication" class="anchor-heading" aria-labelledby="chapter-5-replication"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Chapter 5: Replication
  
  
</h1>
    

<ul>
  <li>
<em>replication</em> - keeping a copy of the same data on multiple machines that are connected via a network</li>
  <li>you might need to replicate data to:
    <ul>
      <li>
<strong>reduce latency</strong> keep data geographically close to your users</li>
      <li>
<strong>increase availability</strong> - allow the system to continue working even if some of its parts have failed</li>
      <li>
<strong>increase throughput</strong> - scale out the number of machines that can serve read queries</li>
    </ul>
  </li>
  <li>all of the difficulty in replication lies in handling changes over time to replicated data</li>
  <li>almost all distributed databases use one of three algorithms:
    <ol>
      <li><em>single leader</em></li>
      <li><em>multi-leader</em></li>
      <li><em>leaderless</em></li>
    </ol>
  </li>
</ul>
<h2 class="no_toc" id="leaders-and-followers">
  
  
    <a href="#leaders-and-followers" class="anchor-heading" aria-labelledby="leaders-and-followers"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Leaders and Followers
  
  
</h2>
    
<ul>
  <li>
<em>replica</em> - each node that stores a copy of the database</li>
  <li>every write to a database must be processed by every replica, otherwise the replica would no longer contain the same data</li>
</ul>
<h3 id="leader-based-replication">
  
  
    <a href="#leader-based-replication" class="anchor-heading" aria-labelledby="leader-based-replication"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Leader-based replication
  
  
</h3>
    
<ul>
  <li>aka <em>active/passive</em> or <em>master-slave</em>
</li>
  <li>generally works like this:
    <ul>
      <li>one replica is designated leader (aka <em>master</em> or <em>primary</em>) and writes are sent to this node</li>
      <li>other replicas are known as <em>followers</em> (<em>read replicas</em>, <em>slaves</em>, <em>secondaries</em>, <em>hot standbys</em>) – when a leader writes new data, changes are sent to replicas via <em>replication log</em> or <em>change stream</em>, and writes are applied the same way they were initially received
        <blockquote>
          <p>there are different definitions for hot, warm, and cold standbys which aren’t material to this section</p>
        </blockquote>
      </li>
      <li>reads can go to leader or any followers</li>
      <li>PostgreSQL (since 9.0), MySQL, Oracle Data Guard, SQL Server’s AlwaysOn Availability Groups, MongoDB, RethinkDB, Espresso, Kafka and RabbitMQ highly available queues all use leader-based replication</li>
    </ul>
  </li>
</ul>
<h4 class="no_toc" id="asynchronous-vs-synchronous">
  
  
    <a href="#asynchronous-vs-synchronous" class="anchor-heading" aria-labelledby="asynchronous-vs-synchronous"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Asynchronous vs. Synchronous
  
  
</h4>
    
<ul>
  <li>replication to followers can either be
    <ul>
      <li>
<em>asynchronous</em> - writes don’t wait for replication to followers to report success to client/user</li>
      <li>
<em>synchronous</em> - writes replicate to all followers before reporting success</li>
    </ul>
  </li>
  <li>in sync models, one bad follower can halt the entirety of the write, so <em>semi-synchronous</em> method is employed where writes are synchronous to a single follower and all others are replicated asynchronously</li>
  <li>often, leader-based is also fully asynchronous, so if leader fails any writes that weren’t replicated are lost</li>
</ul>
<h4 class="no_toc" id="creating-new-followers">
  
  
    <a href="#creating-new-followers" class="anchor-heading" aria-labelledby="creating-new-followers"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Creating New Followers
  
  
</h4>
    
<ul>
  <li>sometimes you need to create a new follower node, but copying files or locking the database isn’t desirable as this won’t reflect all changes and is slow</li>
  <li>a more desirable process might:
    <ol>
      <li>take a snapshot of leader database</li>
      <li>copy snapshot to follower node</li>
      <li>follower connects to leader and requests changes since snapshot – as long as the exact position in the log is known (PostgreSQL - <em>log sequence number</em>, or MySQL - <em>binlog coordinates</em>)</li>
      <li>once backlog of changes are processed, the follower has ‘caught up’</li>
    </ol>
  </li>
</ul>
<h4 class="no_toc" id="node-outages">
  
  
    <a href="#node-outages" class="anchor-heading" aria-labelledby="node-outages"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Node Outages
  
  
</h4>
    
<ul>
  <li>how do we achieve high availability with leader-based replication?
    <ul>
      <li>
<strong>follower failure: catch-up recovery</strong> - a follower knows exact place in log, so if network interruptions or failures happen, follower can connect to leader after resolution and catch up</li>
      <li>
<strong>leader failure: failover</strong> - one of followers needs to be promoted to new leader, which can happen manually or automatically
        <ul>
          <li>steps needed to failover
            <ul>
              <li>determine leader has failed - can happen for many reasons, and might be determined by timeout</li>
              <li>choose new leader - typically, the follower with most up to date data</li>
              <li>reconfigure system to use new leader - clients need to send write requests to new leader, and if old leader comes back on needs to be demoted to follower</li>
            </ul>
          </li>
          <li>some potential failover problems:
            <ul>
              <li>if async is enabled, writes to original leader might cause problems when leader comes back, so these are typically discarded</li>
              <li>two nodes might believe they are both leader - <em>split brain</em>
</li>
              <li>if storage systems outside the database need to be coordinated with the database contents (e.g. an incrementing key in a database, and a Redis cache using those keys – database goes down so some primary keys entries are written to a failover leader but aren’t propagated and need to be discarded, but those primary keys still exist in Redis cache, leading to the exposure of private data (database has 123 as user a, but Redis cache has 123 as user b))</li>
              <li>determining timeout to declare leader ‘dead’ might lead to false positives for longer running tasks</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>
<h4 class="no_toc" id="replication-methods">
  
  
    <a href="#replication-methods" class="anchor-heading" aria-labelledby="replication-methods"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Replication Methods
  
  
</h4>
    
<ul>
  <li>several leader-based replication methods
    <ul>
      <li>
<strong>statement based</strong> - leader sends SQL statements to followers (<code class="language-plaintext highlighter-rouge">INSERT</code>, <code class="language-plaintext highlighter-rouge">UPDATE</code>, <code class="language-plaintext highlighter-rouge">DELETE</code>)
        <ul>
          <li>difficult if there are non-deterministic functions (<code class="language-plaintext highlighter-rouge">NOW()</code>) or side effects (triggers, stored procedures, user-defined functions)</li>
        </ul>
      </li>
      <li>
<strong>write ahead log shipping</strong> - we can use the append only sequence of records to replicate data, used in PostgreSQL and Oracle
        <ul>
          <li>WAL contains very low level data (which bytes where changed in which disk blocks) closely coupling replication and storage engine</li>
        </ul>
      </li>
      <li>
<strong>logical (row-based) log</strong> - store different log format for replication (logical) and for storage engine (physical) – logical log stores changes to database at granularity of rows
        <ul>
          <li>easier to parse as its decoupled from storage engine</li>
        </ul>
      </li>
      <li>
<strong>trigger-based</strong> - move replication to the application layer by using <em>triggers</em> or <em>stored procedures</em> within database
        <ul>
          <li>useful if you need more flexibility, but difficult to maintain</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>
<h4 class="no_toc" id="replication-lag--types-of-consistency">
  
  
    <a href="#replication-lag--types-of-consistency" class="anchor-heading" aria-labelledby="replication-lag--types-of-consistency"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Replication Lag &amp; Types of Consistency
  
  
</h4>
    
<ul>
  <li>
<em>read scaling architecture</em> - many models need only single leader and many read replicas, so you can scale those out to take increased load</li>
  <li>
<strong>eventual consistency</strong> - if app reads from async follower, sometimes that data might be out of date – if you wait for all writes to complete all followers will eventually have up-to-date data</li>
  <li>
<strong>read-after-write consistency</strong> - when a user writes to a database, this guarantee is that if the user refreshes the page they will see their writes reflected, which might not happen if they write to one node then read from a follower that hasn’t been replicated to yet
    <ul>
      <li>you might enforce reading from the leader when reading something a user modified, or using other criteria such as using timestamps of most recent write and serving from replicas that are at least that up to date, either as a logical timestamp (sequence of writes) or actual system clock</li>
      <li>you might also need to provide <em>cross-device</em> read-after-write consistency</li>
    </ul>
  </li>
  <li>
<strong>monotonic reads</strong> - guarantee that users won’t see things moving back in time because their queries were served by two followers that were progressively more stale
    <ul>
      <li>lesser guarantee than strong consistency, but stronger than eventual consistency</li>
    </ul>
  </li>
  <li>
<strong>consistent prefix reads</strong> - guarantees that if a sequence of writes happens in a certain order, anyone reading those writes would see them appear in same order – a problem of <em>causality</em> where one write precedes the write that seems to have caused it, like an answer before a question
    <ul>
      <li>particular problem in partitioned/sharded databases</li>
    </ul>
  </li>
  <li>worth thinking about what would happen if replication lag increases to several minutes or several hours when thinking about what consistency you need to guarantee</li>
</ul>
<h3 id="multi-leader-replication">
  
  
    <a href="#multi-leader-replication" class="anchor-heading" aria-labelledby="multi-leader-replication"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Multi-Leader Replication
  
  
</h3>
    
<ul>
  <li>aka <em>master-master</em> or <em>active/active</em>
</li>
  <li>each node that processes a write must forward to all other nodes</li>
  <li>some databases support by default, but most need external tools to handle (Tungsten Replication for MySQL, BDR for PostgreSQL, and GoldenGate for Oracle)</li>
  <li>use cases for multi-leader replication
    <ul>
      <li>
<strong>multiple datacenters</strong> - rarely makes sense to use multi-leader in a single datacenter, but if you have multiple data centers, you can have a leader in each one, and each leader replicates their changes to other leaders in other datacenters</li>
      <li>
<strong>clients with offline operation</strong> - useful if you have an application that needs to continue to work even when offline (calendar apps, email apps) - data stored on local database acting as leader, and synced when internet is next available. CouchDB operates in this mode by default</li>
      <li>
<strong>collaborative editing</strong> - things like Google Docs allow many people to edit a doc at once, but each local copy is a leader that replicates to all other copies – you need to lock a doc before someone else can use it, but you can make the unit of change as small as a keystroke to limit the locks</li>
    </ul>
  </li>
</ul>
<h4 class="no_toc" id="handling-write-conflicts">
  
  
    <a href="#handling-write-conflicts" class="anchor-heading" aria-labelledby="handling-write-conflicts"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Handling Write Conflicts
  
  
</h4>
    
<ul>
  <li>biggest problem with multi-leader is write conflicts can occur (two leaders make conflicting writes)</li>
  <li>some methods to avoid write conflicts:</li>
  <li>
<strong>conflict avoidance</strong> - simplest way to deal with conflicts is to avoid them – you could make sure that all edits to a record go through the same leader</li>
  <li>
<strong>converging toward a consistent state</strong> - in multi-leader config, there is no defined ordering of writes
    <ul>
      <li>all replication must ensure that data is eventually the same in all replicas, so one method is to resolve conflicts in a <em>convergent</em> way, or to ensure that all replicas must arrive at the same final value when all changes have been replicated</li>
      <li>if timestamp is used, you might use <em>last write wins</em> (LWW)</li>
    </ul>
  </li>
  <li>
<strong>custom conflict resolution logic</strong> - you might need to write application code to resolve conflicts
    <ul>
      <li>
<em>on write</em> - as soon as database system detects conflict, it calls conflict handler to deal</li>
      <li>
<em>on read</em> - all conflicting writes are stored, but next time the data is read, all conflicting writes are given to the application to resolve</li>
    </ul>
  </li>
  <li>other conflict resolution algorithms:
    <ul>
      <li>
<strong>conflict-free replicated datatypes</strong> - family of data structures (maps, sets, etc) that can automatically resolve conflicts in sensible ways</li>
      <li>
<strong>mergeable persistent data structures</strong> - explicit tracking of history similar to git version control</li>
      <li>
<strong>operational transformation</strong> - behind Google Docs and Etherpad</li>
    </ul>
  </li>
</ul>
<h4 class="no_toc" id="multi-leader-replication-topologies">
  
  
    <a href="#multi-leader-replication-topologies" class="anchor-heading" aria-labelledby="multi-leader-replication-topologies"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Multi-Leader Replication Topologies
  
  
</h4>
    
<ul>
  <li>replication topology describes communication path which writes are propagated from one node to another</li>
  <li>
<strong>all-to-all</strong> - every leader sends its writes to every other leader</li>
  <li>
<strong>star</strong> - one designated root node forwards writes to all other nodes (tree)</li>
  <li>
<strong>circular</strong> - each node receives writes from one node and forwards to another</li>
</ul>
<h3 id="leaderless-replication">
  
  
    <a href="#leaderless-replication" class="anchor-heading" aria-labelledby="leaderless-replication"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Leaderless Replication
  
  
</h3>
    
<ul>
  <li>allows any node to accept writes</li>
  <li>Amazon used for its in-house <em>Dynamo</em> system, and Riak, Cassandra, and Voldemort adopted it
    <blockquote>
      <p>not to be confused with AWS’s DynamoDB</p>
    </blockquote>
  </li>
  <li>in a leaderless configuration, failover doesn’t exist, so reads and writes are sent to multiple nodes, and up to date data is determined by version numbers</li>
  <li>how does a node that was offline catch up?
    <ul>
      <li>
<strong>read repair</strong> - when client makes a read from several nodes in parallel, it can detect stale responses by version number</li>
      <li>
<strong>anti-entropy process</strong> - some datastores have a background process that looks for differences in data between replicas and updates the stale data</li>
    </ul>
  </li>
</ul>
<h4 class="no_toc" id="read-and-write-quorum-consistency">
  
  
    <a href="#read-and-write-quorum-consistency" class="anchor-heading" aria-labelledby="read-and-write-quorum-consistency"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Read and Write Quorum Consistency
  
  
</h4>
    
<ul>
  <li>used to determine how many nodes would be required for a write to be successful</li>
  <li>if there are <em>n</em> replicas, every write must be confirmed by <em>w</em> nodes to be considered successful, and we need to query <em>r</em> nodes for each read, so as long as <em>r</em> + <em>w</em> &gt; <em>n</em> we expect an up to date value when reading</li>
</ul>
<h4 class="no_toc" id="limitations-of-quorum-consistency">
  
  
    <a href="#limitations-of-quorum-consistency" class="anchor-heading" aria-labelledby="limitations-of-quorum-consistency"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Limitations of Quorum Consistency
  
  
</h4>
    
<ul>
  <li>even with <em>w</em> + <em>r</em> &gt; <em>n</em>, there are edge cases where stale values might be returned
    <ul>
      <li>if sloppy quorum is used, <em>w</em> writes may end up on different nodes than <em>r</em> reads, so there is no guarantee of overlap</li>
      <li>two concurrent writes, so it is unclear which write happened first – if winner is picked based on timestamp, writes might be lost to clock skew</li>
      <li>write happens concurrent to read</li>
      <li>write succeeds on some replicas and fails on others</li>
      <li>unlucky with timing</li>
    </ul>
  </li>
  <li>monitoring staleness:
    <ul>
      <li>for leader-based replication, you can see how far behind a leader the replicas are as a quantitative measurement, but that is not possible with leaderless because there is no required sequence of writes</li>
    </ul>
  </li>
</ul>
<h4 class="no_toc" id="sloppy-quorums-and-hinted-handoffs">
  
  
    <a href="#sloppy-quorums-and-hinted-handoffs" class="anchor-heading" aria-labelledby="sloppy-quorums-and-hinted-handoffs"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Sloppy Quorums and Hinted Handoffs
  
  
</h4>
    
<ul>
  <li>in distributed leaderless architectures, network outages might knock off too many nodes to reach a quorum, so if a quorum can’t be reached, should we:
    <ul>
      <li>
<strong>sloppy quorums</strong> - accept writes anyway - when network connection is restored, any writes accepted on behalf of a down leader are sent to their respective home (<em>hinted handoffs</em>) – not a quorum at all but an assurance of durability</li>
      <li>return errors for all requests</li>
    </ul>
  </li>
</ul>
<h4 class="no_toc" id="detecting-concurrent-writes">
  
  
    <a href="#detecting-concurrent-writes" class="anchor-heading" aria-labelledby="detecting-concurrent-writes"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Detecting Concurrent Writes
  
  
</h4>
    
<ul>
  <li>writes can arrive in different orders on different nodes, and if each node overwrote the value for a key, the nodes would be permanently inconsistent</li>
  <li>
<strong>last write wins</strong> - you could discard concurrent writes, as long as there is a way to determine which write is more ‘recent’
    <ul>
      <li>only conflict resolution supported in Cassandra, optional in Riak</li>
      <li>achieves goal of eventual convergence at cost of durability - if there are several concurrent writes only the last one will be successful despite all showing as success to user</li>
    </ul>
  </li>
  <li>
<strong>“happens-before” relationship and concurrency</strong> - with two events, A &amp; B, either 1) A happened before B, B happened before A, or A &amp; B are concurrent</li>
</ul>
<h2 id="chapter-summary-4">
  
  
    <a href="#chapter-summary-4" class="anchor-heading" aria-labelledby="chapter-summary-4"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Chapter Summary
  
  
</h2>
    
<ul>
  <li>Replication can serve several purposes:
    <ul>
      <li>
<em>High Availability</em>
        <ul>
          <li>keeping the system running, even when on machine (or several machines, or an entire datacenter) goes down</li>
        </ul>
      </li>
      <li>
<em>Disconnected Operation</em>
        <ul>
          <li>Allowing an application to continue working when there is a network interruption</li>
        </ul>
      </li>
      <li>
<em>Latency</em>
        <ul>
          <li>Placing data geographically close to users, so that users can interact with it faster</li>
        </ul>
      </li>
      <li>
<em>Scalability</em>
        <ul>
          <li>Being able to handle a higher volume of reads than a single machine could handle by performing reads on replicas</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Replication requires careful thinking about concurrency and all the things that could go wrong, and dealing with the consequences of those faults</li>
  <li>at a minimum, need to deal with unavailable nodes and network interruptions</li>
  <li>Three main approaches to replication
    <ul>
      <li>
<em>Single-leader replication</em>
        <ul>
          <li>clients send all writes to a single node (leader) which streams data to other replicas (followers) – reads can be performed on any replica</li>
        </ul>
      </li>
      <li>
<em>Multi-leader replication</em>
        <ul>
          <li>clients send writes to one of several leader nodes and that leader node streams data to everything else</li>
        </ul>
      </li>
      <li>
<em>Leaderless replication</em>
        <ul>
          <li>clients send writes to several nodes in parallel in order to detect and correct nodes with stale data</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>single leader is popular because it is fairly easy to understand and there is no conflict resolution to worry about</li>
  <li>multi-leader and leaderless can be more robust in the presence of faulty nodes and latency spikes but are harder to reason about and only provide weak consistency guarantees</li>
  <li>replication can be synchronous or asynchronous – asynchronous can be fast when system is running smoothly, but failover is more difficult</li>
  <li>some consistency models:
    <ul>
      <li>
<em>read-after-write consistency</em> - users should always see data that they submitted themselves</li>
      <li>
<em>monotonic reads</em> - after users have seen the data at one point in time, they shouldn’t later see the data fromm some earlier point in time</li>
      <li>
<em>consistent prefix reads</em> - users should see the data in a state that makes causal sense: for example, seeing a question and reply in the correct order</li>
    </ul>
  </li>
  <li>because writes can happen concurrently in multi-leader and leaderless, conflicts occur</li>
</ul>
<h1 id="chapter-6-partitioning">
  
  
    <a href="#chapter-6-partitioning" class="anchor-heading" aria-labelledby="chapter-6-partitioning"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Chapter 6: Partitioning
  
  
</h1>
    

<ul>
  <li>for very large datasets or high query throughput, replication isn’t enough, we need to break up data into <em>partitions</em> (aka <em>sharding</em>)
    <blockquote>
      <p><em>partition</em> is <em>shard</em> in MongoDB, Elasticsearch and SolrCloud, <em>region</em> in HBase, <em>tablet</em> in Bigtable, <em>vnode</em> in Cassandra and Riak, <em>vBucket</em> in Couchbase</p>
    </blockquote>
  </li>
  <li>each partition is like a small database on its own</li>
  <li>main use case for partitioning is scalability – different partitions can be placed on different nodes in <em>shared-nothing architecture</em>
</li>
</ul>
<h3 class="no_toc" id="partitioning-and-replication">
  
  
    <a href="#partitioning-and-replication" class="anchor-heading" aria-labelledby="partitioning-and-replication"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Partitioning and Replication
  
  
</h3>
    
<ul>
  <li>partitioning is normally combined with replication for fault tolerance, so copies of partitions are stored on multiple nodes</li>
</ul>
<h3 id="partitioning-of-key-value-data">
  
  
    <a href="#partitioning-of-key-value-data" class="anchor-heading" aria-labelledby="partitioning-of-key-value-data"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Partitioning of Key-Value Data
  
  
</h3>
    
<ul>
  <li>goal of partitioning is to spread data and query load evenly across nodes</li>
  <li>
<em>skewed</em> - if partition is unfair, meaning some nodes have more query load or data than others</li>
  <li>a partition with a disproportionately high load is called a <em>hot spot</em>
</li>
  <li>you might assign values to nodes randomly, but this is disadvantageous if you want to read data since you’d need to guess what node data is on</li>
</ul>
<h4 class="no_toc" id="partitioning-by-key-range">
  
  
    <a href="#partitioning-by-key-range" class="anchor-heading" aria-labelledby="partitioning-by-key-range"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Partitioning by Key Range
  
  
</h4>
    
<ul>
  <li>you might partition by a continuous range of keys, from a minimum to a maximum</li>
  <li>range of keys might not be evenly spaced, so partition boundaries need to adapt to data
    <ul>
      <li>partition boundaries might be chosen by an administrator or by the database itself</li>
    </ul>
  </li>
  <li>within each partition, keys can be kept in sorted order
    <ul>
      <li>the key can treated as a concatenated index to fetch related records</li>
    </ul>
  </li>
  <li>we can use range to do efficient range queries</li>
  <li>downside is that certain access patterns can lead to hot spots, e.g. using a timestamp as a key means all writes end up going to the same partition
    <ul>
      <li>need to use something other than timestamp as the first element of the key</li>
    </ul>
  </li>
</ul>
<h4 class="no_toc" id="partitioning-by-hash-of-key">
  
  
    <a href="#partitioning-by-hash-of-key" class="anchor-heading" aria-labelledby="partitioning-by-hash-of-key"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Partitioning by Hash of Key
  
  
</h4>
    
<ul>
  <li>because of the risk of skew and hot spots, many distributed datastores use a hash function to determine partition for a given key</li>
  <li>doesn’t need to be cryptographically strong
    <ul>
      <li>Cassandra and MongoDB use MD5</li>
      <li>Voldemort uses Fowler-Noll-Vo function</li>
    </ul>
  </li>
  <li>some programming language hash functions might generate a different hash for the same data in different processes</li>
  <li>this can lead to <em>consistent hashing</em>, or partitions are chosen pseudo-randomly - better to avoid the term and call it <em>hash partitioning</em> (consistency is a loaded and ambiguous term)</li>
  <li>this method means you can’t do efficient range queries</li>
  <li>Cassandra reaches a compromise by using <em>compound primary keys</em>, which take the first part of a key for hashing, but additional fields can be used to sort data in Cassandra’s SSTables, which helps with concatenated queries (e.g. hash(user_id), timestamp would allow all updates for a particular user in a timespan)</li>
</ul>
<h4 class="no_toc" id="skewed-workloads-and-relieving-hot-spots">
  
  
    <a href="#skewed-workloads-and-relieving-hot-spots" class="anchor-heading" aria-labelledby="skewed-workloads-and-relieving-hot-spots"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Skewed Workloads and Relieving Hot Spots
  
  
</h4>
    
<ul>
  <li>extreme case where all requests still routed to same partition</li>
  <li>currently, most data systems can’t compensate for this skewed workload, so application code needs to be written to accommodate</li>
  <li>for example, you might add two digits to hot keys, then you must keep track of them to access later</li>
</ul>
<h3 id="partitioning--secondary-indexes">
  
  
    <a href="#partitioning--secondary-indexes" class="anchor-heading" aria-labelledby="partitioning--secondary-indexes"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Partitioning &amp; Secondary Indexes
  
  
</h3>
    
<ul>
  <li>secondary indexes are indispensable for relational databases, but they don’t map neatly to partitions</li>
  <li>two main approaches to partitioning a database with secondary indexes:
    <ol>
      <li>document-based partitioning</li>
      <li>term-based-partitioning</li>
    </ol>
  </li>
</ul>
<h4 class="no_toc" id="partitioning-secondary-indexes-by-document">
  
  
    <a href="#partitioning-secondary-indexes-by-document" class="anchor-heading" aria-labelledby="partitioning-secondary-indexes-by-document"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Partitioning Secondary Indexes by Document
  
  
</h4>
    
<ul>
  <li>primary indexes are maintained (document ids)</li>
  <li>each partition is completely separate, and indexes added are <em>local</em> to the partition</li>
  <li>downsides are that there is no reason that all fields with a particular value would be in the same partition, so queries would need to be sent to all partitions, which might get expensive</li>
  <li>
<em>scatter/gather</em> - querying a partitioned database across all partitions using secondary index, then aggregated the results</li>
  <li>MongoDB, Riak, Cassandra, Elasticsearch, SolrCloud, and VoltDB all use document-partitioned secondary indexes</li>
</ul>
<h4 class="no_toc" id="partitioning-secondary-indexes-by-term">
  
  
    <a href="#partitioning-secondary-indexes-by-term" class="anchor-heading" aria-labelledby="partitioning-secondary-indexes-by-term"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Partitioning Secondary Indexes by Term
  
  
</h4>
    
<ul>
  <li>instead of a local index, we can have a <em>global index</em>, but that global index also needs to be partitioned across nodes</li>
  <li>use either a hash of a term or the term itself to generate the index</li>
  <li>has the benefit of making reads faster, but writes are slower and more complicated since many nodes might need to be accessed to write the index</li>
</ul>
<h3 id="rebalancing-partitions">
  
  
    <a href="#rebalancing-partitions" class="anchor-heading" aria-labelledby="rebalancing-partitions"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Rebalancing Partitions
  
  
</h3>
    
<ul>
  <li>over time, the database changes, e.g.:
    <ul>
      <li>query throughput increases, and you want to add CPU</li>
      <li>dataset size increases and you want to add more RAM</li>
      <li>machine fails, and other machines need to take over responsibilities</li>
    </ul>
  </li>
  <li>
<strong>rebalancing</strong> - process of moving load from one load to another</li>
  <li>after rebalancing, certain requirements should be met
    <ul>
      <li>the load should be shared fairly between nodes in the cluster</li>
      <li>while rebalancing is happening, the database should continue accepting reads and writes</li>
      <li>no more data than necessary should be moved between nodes, to make rebalancing fast and minimize network and disk I/O load</li>
    </ul>
  </li>
</ul>
<h4 class="no_toc" id="strategies-for-rebalancing">
  
  
    <a href="#strategies-for-rebalancing" class="anchor-heading" aria-labelledby="strategies-for-rebalancing"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Strategies for Rebalancing
  
  
</h4>
    
<ul>
  <li>don’t use modulo, since that encodes a specific number of nodes say, mod <em>n</em> means if you have n+1 nodes, all data needs to be shifted</li>
</ul>
<h5 class="no_toc" id="fixed-number-of-partitions">
  
  
    <a href="#fixed-number-of-partitions" class="anchor-heading" aria-labelledby="fixed-number-of-partitions"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Fixed Number of Partitions
  
  
</h5>
    
<ul>
  <li>practice of assigning many more partitions to each node, so any new node can ‘borrow’ partitions from each node until load is evenly spread</li>
  <li>e.g. each node has 100 partitions, across 10 nodes, that is 1,000 partitions. if an 11th node is adding, that node can take ~9 partitions from each node</li>
  <li>number of partitions is usually fixed when database is set up, making this less ideal if the size of the data set is variability (might grow much larger over time)</li>
  <li>hard to achieve ‘just right’ partition amount</li>
</ul>
<h5 class="no_toc" id="dynamic-partitioning">
  
  
    <a href="#dynamic-partitioning" class="anchor-heading" aria-labelledby="dynamic-partitioning"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Dynamic Partitioning
  
  
</h5>
    
<ul>
  <li>fixed number of partitions wouldn’t work well with key range partitioned databases, so dynamic partitioning might be more effective</li>
  <li>when a partition grows larger than a fixed size  (HBase, default is 10GB), that partition is split and might be sent to separate nodes to balance the load</li>
  <li>if partition shrinks, it might be combined with adjacent partition</li>
  <li>can also be used for hash-partitioned data</li>
</ul>
<h5 class="no_toc" id="partitioning-proportionally-to-nodes">
  
  
    <a href="#partitioning-proportionally-to-nodes" class="anchor-heading" aria-labelledby="partitioning-proportionally-to-nodes"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Partitioning Proportionally to Nodes
  
  
</h5>
    
<ul>
  <li>have a fixed number of partitions per node, and those partitions grow larger with dataset size, but adding a node decreases size of partitions again</li>
  <li>requires hash-based partitioning, as new node randomly takes data from other nodes, and if hash-based partitioning isn’t used, this would lead to unfair splits</li>
</ul>
<h4 class="no_toc" id="automatic-or-manual-rebalancing">
  
  
    <a href="#automatic-or-manual-rebalancing" class="anchor-heading" aria-labelledby="automatic-or-manual-rebalancing"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Automatic or Manual Rebalancing
  
  
</h4>
    
<ul>
  <li>generally a good idea to have a human in the loop, as rebalancing is expensive and automation might be unpredictable</li>
</ul>
<h3 id="request-routing">
  
  
    <a href="#request-routing" class="anchor-heading" aria-labelledby="request-routing"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Request Routing
  
  
</h3>
    
<ul>
  <li>how does a client know which node to send a request to (who makes the routing decision)?</li>
  <li>an example of a more general problem called <em>service discovery</em>
</li>
  <li>a few different approaches to the problem:
    <ol>
      <li>allow clients to contact any node (e.g. via a round-robin loader balancer) – if that node contains the information, return it, otherwise forward the request to the correct node</li>
      <li>send all requests to a routing tier first acting as a partition-aware load balancer</li>
      <li>require that clients be aware of partitioning and assignment of partitions, so a client can connect directly to a node</li>
    </ol>
  </li>
  <li>many distributed data systems rely on a coordination service such as Zookeeper to keep track of this cluster metadata</li>
  <li>Espresso uses Helix</li>
  <li>HBase, SolrCloud, and Kafka use Zookeeper</li>
  <li>MongoDB uses its own <em>config server</em> and <em>mongos</em> daemon as the routing tier</li>
  <li>Cassandra and Riak use <em>gossip protocol</em>, putting more complexity into database nodes but doesn’t require external coordination service</li>
  <li>DNS is sufficient for IP address lookup</li>
</ul>
<h2 id="chapter-summary-5">
  
  
    <a href="#chapter-summary-5" class="anchor-heading" aria-labelledby="chapter-summary-5"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Chapter Summary
  
  
</h2>
    
<ul>
  <li>goal of partitioning is to spread the data and query load evenly across multiple machines, avoiding hot spots</li>
  <li>this requires a partitioning scheme that is appropriate to the data, and rebalancing partitions when nodes are added to or removed from the cluster</li>
  <li>two types of partitioning
    <ul>
      <li>
<strong>key range partitioning</strong>
        <ul>
          <li>keys are sorted and a partition owns all the keys from some minimum up to some max.</li>
          <li>sorting has the advantage that efficient range queries are possible, but there is risk of hot spots if application often access keys that are close together in the sorted order</li>
        </ul>
      </li>
      <li>
<strong>hash partitioning</strong>
        <ul>
          <li>where a has function is applied to each key, and a partition owns a range of hashes</li>
          <li>destroys the ordering of keys making range queries inefficient, but may distribute load more evenly</li>
          <li>when partitioning by hash it is common to create a fixed number of partitions in advance, to assign several partitions to each node, and to move entire partitions form one node to another when nodes are added or removed</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>hybrid approaches are also possible, e.g. using one part for the hash and the second part for the sort order</li>
  <li>two types of secondary index partitions
    <ul>
      <li>
<strong>document-partitioned indexes (local indexes)</strong>
        <ul>
          <li>secondary indexes stored in the same partition as the primary key and value</li>
          <li>only a single partition needs to be updated on write, but read of secondary index requires scatter/gather across all partitions</li>
        </ul>
      </li>
      <li>
<strong>term-partitioned indexes (global indexes)</strong>
        <ul>
          <li>secondary index are partitioned separately using indexed values</li>
          <li>entry in the secondary index may include records from all partitions of the primary key</li>
          <li>when document is written, several partitions of the secondary index need to be updated, however a read can be served from a single partition</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>
<h1 id="chapter-7-transactions">
  
  
    <a href="#chapter-7-transactions" class="anchor-heading" aria-labelledby="chapter-7-transactions"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Chapter 7: Transactions
  
  
</h1>
    
<h3 id="what-is-a-transaction">
  
  
    <a href="#what-is-a-transaction" class="anchor-heading" aria-labelledby="what-is-a-transaction"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> What is a Transaction?
  
  
</h3>
    
<ul>
  <li>many things can go wrong with modern data systems, and thinking around how to tolerate those faults is difficult</li>
  <li>
<strong>transactions</strong> are a way to group reads and writes into one unit of work that either succeeds (<em>commits</em>) or fails (<em>aborts</em>, or <em>rollbacks</em>) to simplify the programming model for applications accessing a database</li>
  <li>
<strong>safety guarantees</strong> - using transactions, applications are free to ignore certain potential error scenarios and concurrency issues because the database takes care of them</li>
  <li>the idea of a <em>transaction</em> came out of IBM’s System R (1975), and modern transaction support is very similar still</li>
</ul>
<h3 id="acid">
  
  
    <a href="#acid" class="anchor-heading" aria-labelledby="acid"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> ACID
  
  
</h3>
    
<ul>
  <li>term coined in 1983 by Theo Harder and Andreas Reuter to document fault-tolerance mechanisms of databases</li>
  <li>ACID is ambiguous and depends on implementation</li>
  <li>opposite is BASE (Basically Available, soft state, and eventual consistency), although this term was somewhat of a joke</li>
</ul>

<p><strong>Atomicity</strong></p>
<ul>
  <li>all writes either succeed (commit) or don’t (rollback), so if a fault happens during a write there is no partial write state</li>
  <li>
<em>abortability</em> might be a better term
    <blockquote>
      <p>not a principle of concurrency, as in some domains concurrency means that no threads could see a half-finished state</p>
    </blockquote>
  </li>
</ul>

<p><strong>Consistency</strong></p>
<ul>
  <li>
<em>consistency</em> is an overloaded term – might mean: replica consistency, consistent hashing, linearizability in the C in CAP theorem, or in the ACID context “being in a good state”</li>
  <li>in ACID context, consistency means that your data doesn’t violate any <em>invariants</em>, or generally statements about your data that must be true, e.g. that no invoice dollar amounts are negative, that all accounts are balanced across all nodes, etc.</li>
  <li>databases can’t typically guarantee invariants aren’t violated, so <em>consistency</em> in this context is an attribute of the application rather than the database</li>
</ul>

<p><strong>Isolation</strong></p>
<ul>
  <li>concurrently executing transactions are isolated from each other</li>
  <li>typically cast as <em>serializability</em>, or the idea that each transaction can pretend that it is the only transaction running, as if transactions are run serially (one after another) even if it was actually concurrently</li>
  <li>in practice, serial isolation is rarely used because it has a performance penalty, so often, <em>snapshot isolation</em> is implemented</li>
</ul>

<p><strong>Durability</strong></p>
<ul>
  <li>the promise that once a transaction has completed, data won’t be forgotten</li>
  <li>data is fsync’d to nonvolatile storage (HDD or SSD), or written to write-ahead log, or in distributed systems, replicated to nodes</li>
  <li>no such thing as perfect durability, since all nodes and backups could be destroyed</li>
</ul>
<h4 class="no_toc" id="multi-object-writes">
  
  
    <a href="#multi-object-writes" class="anchor-heading" aria-labelledby="multi-object-writes"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Multi-object Writes
  
  
</h4>
    
<ul>
  <li>atomicity and isolation should apply when multiple objects need to be updated in a transaction, e.g. one table is updated, then another object is incremented in another table (typically achieved by explicitly wrapping SQL as a transaction e.g., <code class="language-plaintext highlighter-rouge">BEGIN TRANSACTION [...] COMMIT</code>)</li>
  <li>some use cases for multi-object atomicity and isolation
    <ul>
      <li>foreign key updates</li>
      <li>in a document data model, fields that need to be updated are within the same document, but if denormalized data is stored that require two or more documents to be updated, you need multi-object guarantees</li>
      <li>databases with secondary indexes</li>
    </ul>
  </li>
</ul>
<h4 class="no_toc" id="single-object-writes">
  
  
    <a href="#single-object-writes" class="anchor-heading" aria-labelledby="single-object-writes"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Single-object Writes
  
  
</h4>
    
<ul>
  <li>databases and datastores almost universally aim to provide atomicity and isolation on the level of a single object on a single node</li>
  <li>some provide more complex operations such as an increment operation (removing the need for a read, modify, write cycle)</li>
  <li>also, some provide compare-and-set operations, which only allow a value to be changed if it has not been concurrently changed by someone else</li>
</ul>
<h4 class="no_toc" id="handling-errors-and-aborts">
  
  
    <a href="#handling-errors-and-aborts" class="anchor-heading" aria-labelledby="handling-errors-and-aborts"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Handling Errors and Aborts
  
  
</h4>
    
<ul>
  <li>the whole point of aborts are to allow safe retries, although certain ORM tools don’t allow them out of the box (Rail’s ActiveRecord and Django)</li>
  <li>retries aren’t foolproof:
    <ul>
      <li>network might fail upon alerting the client to a successful commit,</li>
      <li>if the error is due to overload,</li>
      <li>if there is a more permanent error,</li>
      <li>if the transaction has side effects, or</li>
      <li>if the client process fails while writing causing data loss</li>
    </ul>
  </li>
</ul>
<h3 id="weak-non-serializable-isolation-levels">
  
  
    <a href="#weak-non-serializable-isolation-levels" class="anchor-heading" aria-labelledby="weak-non-serializable-isolation-levels"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Weak (Non-Serializable) Isolation Levels
  
  
</h3>
    
<ul>
  <li>concurrency issues (race conditions) only come into play when two or more transactions are reading or modifying the same data</li>
  <li>
<strong>transaction isolation</strong> - databases trying to hide concurrency issues from application developers</li>
  <li>
<em>serializable</em> isolation is the highest level, but there is a performance cost, so databases mostly use weaker forms of isolation</li>
</ul>
<h4 id="read-committed">
  
  
    <a href="#read-committed" class="anchor-heading" aria-labelledby="read-committed"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Read Committed
  
  
</h4>
    
<ul>
  <li>makes two guarantees:
    <ul>
      <li>
<strong>no dirty reads</strong> - when reading from a database, you will only see data that has been committed</li>
      <li>
<strong>no dirty writes</strong> - when writing to a database you will only overwrite data that has been committed, typically achieved by delaying the second write until the first write’s transaction is committed or aborted</li>
    </ul>
  </li>
  <li>default setting in Oracle 11g, PostgreSQL, SQL Server 2012, MemSQL</li>
  <li>most commonly, databases prevent dirty writes by implementing row locks</li>
  <li>for dirty reads, locks for writes would be bad for operability – one long-running write might slow down many reads, so typically, databases will remember the old value during a write and give that to any read until the write is committed</li>
</ul>
<h4 id="snapshot-isolation-and-repeatable-read">
  
  
    <a href="#snapshot-isolation-and-repeatable-read" class="anchor-heading" aria-labelledby="snapshot-isolation-and-repeatable-read"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Snapshot Isolation and Repeatable Read
  
  
</h4>
    
<ul>
  <li>
<strong>non-repeatable read (read skew)</strong> - one in which data read twice inside the same transaction cannot be guaranteed to contain the same value. Depending on the isolation level, another transaction could have nipped in and updated the value between the two reads.</li>
  <li>This is allowed in read committed isolation, but might not be tolerable for backups, analytics queries, or integrity checks</li>
  <li>
<strong>snapshot isolation</strong> - each transaction reads from a consistent snapshot of the database, or, a transaction sees all data that was committed to the database at the start of the transaction</li>
  <li><em>readers never block writers, and writers never block readers</em></li>
  <li>
<strong>multi-version concurrency control (MVCC)</strong> - used to keep several versions of an object side by side</li>
  <li>different implementations use different terms for snapshot isolation (Oracle - <em>serializable</em>, PostgreSQL and MySQL - <em>repeatable read</em>) – there is no agreement on what <em>snapshot isolation</em>/<em>repeatable read</em> is per SQL standard</li>
</ul>
<h4 class="no_toc" id="lost-updates">
  
  
    <a href="#lost-updates" class="anchor-heading" aria-labelledby="lost-updates"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Lost Updates
  
  
</h4>
    
<ul>
  <li>if two writes occur concurrently, the second write might complete and clobber the first, especially in a <em>read-modify-write</em> cycle</li>
  <li>one way around this is <strong>atomic write operations</strong>, or something like</li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><div class="table-wrapper"><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
</pre></td>
<td class="rouge-code"><pre><span class="k">UPDATE</span> <span class="n">counters</span> <span class="k">SET</span> <span class="n">value</span> <span class="o">=</span> <span class="n">value</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">WHERE</span> <span class="k">key</span> <span class="o">=</span> <span class="s1">'foo</span><span class="se">''</span><span class="s1">
</span></pre></td>
</tr></tbody></table></div></code></pre></div></div>

<ul>
  <li>you might also explicitly lock rows using SQL’s <code class="language-plaintext highlighter-rouge">SELECT * FROM tbl WHERE value = 'abc' FOR UPDATE</code> in a transaction</li>
  <li>you could also automatically detect lost updates and abort a transaction (supported by PostgreSQL’s repeatable read, Oracle’s serializable, SQL Server’s snapshot isolation, but not by MySQL’s repeatable read)</li>
  <li>another way is to do a compare-set operation (which might not fail if snapshot isolation is enabled)</li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><div class="table-wrapper"><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td>
<td class="rouge-code"><pre><span class="k">UPDATE</span> <span class="n">wiki_pages</span> <span class="k">SET</span> <span class="n">content</span> <span class="o">=</span> <span class="s1">'new content'</span>
  <span class="k">WHERE</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">1234</span> <span class="k">and</span> <span class="n">content</span> <span class="o">=</span> <span class="s1">'old content'</span><span class="p">;</span>
</pre></td>
</tr></tbody></table></div></code></pre></div></div>
<h4 class="no_toc" id="write-skews-and-phantoms">
  
  
    <a href="#write-skews-and-phantoms" class="anchor-heading" aria-labelledby="write-skews-and-phantoms"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Write Skews and Phantoms
  
  
</h4>
    
<ul>
  <li>
<strong>write skew anomaly</strong> - two transactions (T1 and T2) concurrently read an overlapping data set (e.g. values V1 and V2), concurrently make disjoint updates (e.g. T1 updates V1, T2 updates V2), and finally concurrently commit, neither having seen the update performed by the other</li>
  <li>
<strong>phantom</strong> - where a write in one transaction changes the results of a search query in another transaction – often occurs when a check is executed for absence of rows matching a search condition and a write adds a row matching the same condition, so there is nothing to attach a lock onto with a <code class="language-plaintext highlighter-rouge">SELECT FOR UPDATE</code> query</li>
</ul>

<p>Imagine Alice and Bob are two on-call doctors dealing with the invariant that one doctor always needs to be on call. They both initiate a request for a day off at the same time:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><div class="table-wrapper"><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td>
<td class="rouge-code"><pre>ALICE                                   BOB

┌─ BEGIN TRANSACTION                    ┌─ BEGIN TRANSACTION
│                                       │
├─ currently_on_call = (                ├─ currently_on_call = (
│   select count(*) from doctors        │    select count(*) from doctors
│   where on_call = true                │    where on_call = true
│   and shift_id = 1234                 │    and shift_id = 1234
│  )                                    │  )
│  // now currently_on_call = 2         │  // now currently_on_call = 2
│                                       │
├─ if (currently_on_call  2) {          │
│    update doctors                     │
│    set on_call = false                │
│    where name = 'Alice'               │
│    and shift_id = 1234                ├─ if (currently_on_call &gt;= 2) {
│  }                                    │    update doctors
│                                       │    set on_call = false
└─ COMMIT TRANSACTION                   │    where name = 'Bob'
                                        │    and shift_id = 1234
                                        │  }
                                        │
                                        └─ COMMIT TRANSACTION
</pre></td>
</tr></tbody></table></div></code></pre></div></div>

<ul>
  <li>one method around this is to <em>materialize conflicts</em>, or explicitly create objects for those search conditions so locks can be applied directly, although it can be hard and error-prone to materialize conflicts</li>
</ul>
<h3 id="serializability">
  
  
    <a href="#serializability" class="anchor-heading" aria-labelledby="serializability"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Serializability
  
  
</h3>
    
<ul>
  <li>serializability is the strongest form of isolation because:
    <ul>
      <li>isolation levels are hard to understand and variously implemented</li>
      <li>application code might not clearly tell you what isolation level you need to run at</li>
      <li>there are no good tools to detect race conditions because they are non-deterministic and subject to timing</li>
    </ul>
  </li>
  <li>three current methods to implement serializability: actual serialized executions, two-phase locking, and serializable snapshot isolation (SSI)</li>
</ul>
<h4 id="actual-serial-execution">
  
  
    <a href="#actual-serial-execution" class="anchor-heading" aria-labelledby="actual-serial-execution"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Actual Serial Execution
  
  
</h4>
    
<ul>
  <li>simplest way to avoid concurrency problems is to execute the queries serially</li>
  <li>historically, this was difficult because a single-threaded loop for executing transactions wasn’t feasible:
    <ul>
      <li>cost of RAM too high</li>
      <li>OLTP transactions were disambiguated from analytic transactions</li>
    </ul>
  </li>
  <li>downsides of serialized execution:
    <ul>
      <li>throughput limited to a single core CPU, which is difficult for high write throughput use cases</li>
    </ul>
  </li>
  <li>constraints of serial execution
    <ul>
      <li>every transaction must be small and fast</li>
      <li>active dataset must fit into memory</li>
      <li>write throughput needs to be low enough to be handled by single CPU or partitioned without requiring cross-partition coordination</li>
      <li>cross-partition transactions are possible but limited</li>
    </ul>
  </li>
</ul>
<h5 class="no_toc" id="stored-procedures">
  
  
    <a href="#stored-procedures" class="anchor-heading" aria-labelledby="stored-procedures"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Stored Procedures
  
  
</h5>
    
<ul>
  <li>a way of encapsulating interactive multi-statement transactions that are often required of today’s websites, or, the ability to complete multiple database queries (e.g., for an airline: query flights, book tickets, change seats, all within the same sesssion or as part of the same form submission)</li>
  <li>stored procedure can execute very fast, provided all data is in memory</li>
  <li>stored procedures can be difficult because:
    <ul>
      <li>each database vendor has a language for stored procedures (although many modern database systems are allowing for general purpose programming languages to be used)</li>
      <li>code running in a database is difficult to manage (debug, check in to version control, etc.)</li>
    </ul>
  </li>
</ul>
<h5 class="no_toc" id="partitioning">
  
  
    <a href="#partitioning" class="anchor-heading" aria-labelledby="partitioning"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Partitioning
  
  
</h5>
    
<ul>
  <li>if you can find a way of partitioning a dataset so that each transaction only needs to read and write within a single partition, each partition can have its own transaction thread</li>
  <li>performance drops immensely when multiple partitions are used</li>
</ul>
<h4 id="two-phase-locking-2pl">
  
  
    <a href="#two-phase-locking-2pl" class="anchor-heading" aria-labelledby="two-phase-locking-2pl"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Two-Phase Locking (2PL)
  
  
</h4>
    
<ul>
  <li>only widely used algorithm for serializability for ~30 years (up to 1970s)
    <blockquote>
      <p>2PL is not 2PC</p>
    </blockquote>
  </li>
  <li>if anyone wants to write (modify or delete) an object, exclusive access is required, blocking both readers and writers with locks</li>
  <li>this distinguishes it from snapshot isolation, where readers never block writers and writers never block readers, and this isolation protects against most race conditions</li>
  <li>2PL is serializability model used by MySQL (InnoDB) and SQL Server, and is repeatable read isolation in DB2</li>
  <li>each object has a lock, operating in either <em>shared</em> or <em>exclusive</em> mode
    <ul>
      <li>reading an object requires getting lock in <em>shared</em> mode, and many transactions can hold the lock</li>
      <li>once a transaction wants to write, it acquires the <em>exclusive</em> lock, and only one of those is every allowed to be held</li>
      <li>you can upgrade a shared to an <em>exclusive</em> lock</li>
      <li>must hold the lock until transaction commits or aborts, which is second part of two phase: <em>first phase</em> - transaction is executing / <em>exclusive</em> lock acquired, <em>second phase</em> - transaction ends / locks released</li>
    </ul>
  </li>
  <li>
<strong>deadlock</strong> can occur when one transaction is waiting on another to finish</li>
  <li>because of acquiring all those locks and 0 concurrency, performance is not great. also, deadlocks that require abort and retry are wasted work</li>
  <li>in order to prevent phantoms, <em>predicate locks</em> need to be created – these locks are applied to objects that meet certain conditions.</li>
  <li>predicate locks do not perform well, so <em>index-range locks</em> (aka <em>next key locking</em> are needed, which are a more generalizable way to create predicate locks (instead of creating a predicate lock on a room 123 between 12 and 1, a predicate lock could be added to lock all bookings for room 123)</li>
</ul>
<h4 id="serializable-snapshot-isolation-ssi">
  
  
    <a href="#serializable-snapshot-isolation-ssi" class="anchor-heading" aria-labelledby="serializable-snapshot-isolation-ssi"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Serializable Snapshot Isolation (SSI)
  
  
</h4>
    
<ul>
  <li>fairly new, first described in 2008</li>
  <li>two types of concurrency control:
    <ul>
      <li>
<em>pessimistic</em> the assumption is that if anything might go wrong, its better to wait until the situation is safe again before doing anything, e.g., acquiring <em>exclusive</em> locks
        <blockquote>
          <p>like <em>mutual exclusions</em> (mutex) which are used to protect data structures in multi-threaded programming</p>
        </blockquote>
      </li>
      <li>
<em>optimistic</em> - instead of blocking, transactions continue anyway, in the hope that things turn out all right, and if a transaction breaks an isolation then it will be aborted</li>
    </ul>
  </li>
  <li>based on snapshot isolation – all transactions read from a consistent snapshot of the database</li>
  <li>the idea is to limit the rate of aborts, which significantly affects performance of SSI</li>
</ul>
<h3 id="chapter-summary-6">
  
  
    <a href="#chapter-summary-6" class="anchor-heading" aria-labelledby="chapter-summary-6"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Chapter Summary
  
  
</h3>
    
<ul>
  <li>Transactions are an abstraction layer that allows an application to pretend that certain concurrency problems and certain kinds of hardware and software faults don’t exist. Many errors reduced to simple <em>transaction abort</em>, and the application can just retry</li>
  <li>transactions probably won’t help applications with simple access patterns (read or write a single record)</li>
  <li>without transactions:
    <ul>
      <li>various error scenarios (processes crashing, network interruptions, power outages, disk full, unexpected concurrency, etc.) mean data can become inconsistent e.g., denormalized data can go out of sync with source data</li>
      <li>it becomes very difficult to reason about the effects that complex interacting accesses can have on the database</li>
    </ul>
  </li>
  <li>several widely used methods of concurrency control: <em>read commited</em>, <em>snapshot isolation</em> (sometimes called <em>repeatable read</em>) and <em>serializable</em>
</li>
  <li>examples of race conditions
    <ul>
      <li>
<strong>dirty reads</strong> - one client reads another client’s writes before they have been committed. read committed and stronger prevent dirty reads</li>
      <li>
<strong>dirty writes</strong> - one client overwrites the data that another client has written but not yet committed. almost all transaction implementations prevent dirty writes</li>
      <li>
<strong>read skew (nonrepeatable reads)</strong> - a client sees different parts of the database at different times. most commonly prevented by snapshot isolation, which allows a transaction to read from a consistent snapshot at one point of time, which is typically implemented with <em>multi-version concurrency control</em> (MVCC)</li>
      <li>
<strong>lost updates</strong> - two clients concurrently perform a read-modiy-write cycle. One overwrites the other’s write without incorporating changes, so data is lost. some implementations of snapshot isolation prevent this, while others require a manual lock (<code class="language-plaintext highlighter-rouge">SELECT [...] FOR UPDATE</code>)</li>
      <li>
<strong>write skew</strong> - a transaction reads something, makes a decision based on the value it saw, and writes the decision to the database. by the time the write is made, the premise of the decision is no longer true. only prevented by serializable isolation</li>
      <li>
<strong>phantom reads</strong> - a transaction reads the objects that match some search condition and another client makes a write that affects the results of that search. snapshot isolation prevents straightforward phantom reads, but phantoms in the context of write skew require special treatment, such as index-range locks</li>
    </ul>
  </li>
  <li>weak isolation protects against some of these race conditions, but the application developer might need to handle others manually. only full prevention is serializability, which takes three forms:
    <ul>
      <li>
<strong>literally executing transactions in serial order</strong> - if you can make each transaction very fast to execute, and the transaction throughput is low enough to process on a single CPU core, this is simple and effective</li>
      <li>
<strong>two-phase locking</strong> - for decades this has been the standard way of implementing serializability, but many apps avoid using it because of its performance characterisitics</li>
      <li>
<strong>serializable snapshot isolation (SSI)</strong> - a fairly new algorithm that avoids most of the downsides of previous approaches. uses an optimistic approach, allowing transactions to proceed without blocking. when a transaction wants to commit, it is checked, and it is aborted if the execution was not serializable.</li>
    </ul>
  </li>
</ul>
<h1 id="chapter-8-the-trouble-with-distributed-systems">
  
  
    <a href="#chapter-8-the-trouble-with-distributed-systems" class="anchor-heading" aria-labelledby="chapter-8-the-trouble-with-distributed-systems"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Chapter 8: The Trouble with Distributed Systems
  
  
</h1>
    
<h3 id="faults-and-partial-failures">
  
  
    <a href="#faults-and-partial-failures" class="anchor-heading" aria-labelledby="faults-and-partial-failures"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Faults and Partial Failures
  
  
</h3>
    
<p>Writing a program on a single computer, things typically work or they don’t. When the hardware is working, the same operation should always produce the same output (<em>deterministic</em>).</p>

<p>Computers are deliberately designed for total system failure when an internal fault occurs rather than producing the wrong result, because the wrong result is hard to debug.</p>

<p>If we are writing software to run on several computers, things are completely different. In distributed systems, there may be parts of the system that are broken in some unpredictable way, resulting in a <em>partial failure</em>. These <em>partial failures</em> tend to be <em>non-deterministic</em> and difficult to reason about.</p>
<h4 class="no_toc" id="cloud-computing-and-supercomputing">
  
  
    <a href="#cloud-computing-and-supercomputing" class="anchor-heading" aria-labelledby="cloud-computing-and-supercomputing"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Cloud Computing and Supercomputing
  
  
</h4>
    
<p>There are two spectrums on how to build large-scale computer systems:</p>

<ol>
  <li>
    <p><em>high-performance computer (HPC)</em> - supercomputers with thousands of CPUs, used for computationally intensive scientific computing tasks</p>
  </li>
  <li>
    <p><em>cloud computing</em> - not well defined, but typically associated with multi-tenant datacenters, commodity computers, elastic/on-demand resource allocation, and metered billing</p>
  </li>
</ol>

<p>These philosophies handle faults differently. One approach for supercomputers is if there is any fault, to fail the entire system.</p>

<div class="table-wrapper"><table>
  <thead>
    <tr>
      <th>Supercomputers</th>
      <th>Cloud Computer</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>batch jobs can be started and stopped fairly easily</td>
      <td>many internet applications are online, and any service unavailability is unacceptable</td>
    </tr>
    <tr>
      <td>built from specialized hardware and communicate through <em>remote direct memory access</em> (RDMA) so faults are infrequent</td>
      <td>due to economies of scale can be provided at lower cost but has higher failure rates</td>
    </tr>
    <tr>
      <td>use specialized network topologies yielding higher performance</td>
      <td>often communicate through IP and Ethernet arranged in Clos topologies that provide high bisection bandwith</td>
    </tr>
    <tr>
      <td>assume all their nodes are close</td>
      <td>nodes might be geographically distributed</td>
    </tr>
  </tbody>
</table></div>

<p>If we want to make distributed systems work, we must accept the possibility of partial failure and build fault tolerance mechanisms, i.e., to build reliable systems from unreliable components.</p>
<h3 id="unreliable-networks">
  
  
    <a href="#unreliable-networks" class="anchor-heading" aria-labelledby="unreliable-networks"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Unreliable Networks
  
  
</h3>
    
<p>Many distributed systems are <em>shared-nothing systems</em>, i.e., a bunch of machines connected by a network without the ability to access each other’s memory or disk. This has become the dominant way to build systems because:</p>

<ul>
  <li>comparatively cheap</li>
  <li>requires no special hardware</li>
  <li>makes use of commoditized cloud computing services</li>
  <li>achieves high reliability through redundancy across multiple geographically distributed datacenters</li>
</ul>

<p>The internet and internal networks are <em>asynchronous packed networks</em>, meaning one node can send a message (a packet) to another node, but no guarantees when it will arrive or if it will arrive at all. If you send a request to another node and don’t receive a response, it is <em>impossible</em> to tell why</p>
<h4 class="no_toc" id="network-faults-in-practice">
  
  
    <a href="#network-faults-in-practice" class="anchor-heading" aria-labelledby="network-faults-in-practice"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Network Faults in Practice
  
  
</h4>
    
<p>Network faults (<em>network partitions</em> or <em>netsplits</em>) can be surprisingly common, e.g.,</p>

<ul>
  <li>EC2 has frequent transient network glitches</li>
  <li>sharks could bite undersea cables</li>
  <li>software upgrade for a switch could trigger a network topology reconfig</li>
</ul>

<p>If software is put in an unanticipated situation, it might do arbitrarily unexpected things. Handling faults doesn’t always mean <em>tolerating</em> them; you might just raise the error.</p>
<h4 class="no_toc" id="detecting-faults">
  
  
    <a href="#detecting-faults" class="anchor-heading" aria-labelledby="detecting-faults"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Detecting Faults
  
  
</h4>
    
<p>Many systems need to automatically detect nodes:</p>

<ul>
  <li>load balancer needs to stop sending requests (take <em>out of rotation</em>)</li>
  <li>in single leader replication, leader <em>failover</em>
</li>
</ul>

<p>Some methods of detecting a failure might be:</p>

<ul>
  <li>if you send requests to a node that is running but no process is listening, the OS will close or refuse TCP connections wtih a <code class="language-plaintext highlighter-rouge">RST</code> or <code class="language-plaintext highlighter-rouge">FIN</code> packet</li>
  <li>if the node’s OS is still running, a script can notify other nodes about crash</li>
  <li>you might be able to query the network switches themselves to detect hardware failure</li>
  <li>router might see that an IP address is unavailable and send an ICMP Destination Unreachable packet.</li>
</ul>
<h4 class="no_toc" id="timeouts-and-unbounded-delays">
  
  
    <a href="#timeouts-and-unbounded-delays" class="anchor-heading" aria-labelledby="timeouts-and-unbounded-delays"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Timeouts and Unbounded Delays
  
  
</h4>
    
<p>How long should the timeout be? A long timeout means a long wait to see if node is dead, and a short timeout might incorrectly declare nodes dead for longer running queries. Prematurely declaring a node dead is problematic, as it might just be operating slowly under load. Declaring the node dead might cause a <em>cascading failure</em> as the system can’t cope with increased load and fewer resources.</p>

<p>Asynchronous networks have <em>unbounded delays</em>, or, there is no upper limit on time it takes for packet to arrive.</p>
<h5 class="no_toc" id="network-congestion-and-queueing">
  
  
    <a href="#network-congestion-and-queueing" class="anchor-heading" aria-labelledby="network-congestion-and-queueing"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Network Congestion and Queueing
  
  
</h5>
    
<p>Variability in packet delays most often due to queueing.</p>

<ul>
  <li>If several nodes send packets simultaneously, the network switch queues them, and on a busy network, the queue might fill up (<em>network congestion</em>).</li>
  <li>If all CPU cores are busy, the OS queues up the request.</li>
  <li>TCP performs <em>flow control</em> (aka <em>congestion avoidance</em> or <em>backpressure</em>) to limit is own rate of sending to avoid over-burdening a network link or receiving node</li>
</ul>

<p>Choosing timeouts is trial and error, and the balance is between failure detection delay and risk of premature timeouts. Systems that continually measure repsonse times and variability (<em>jitter</em>) are better than manually tuning.</p>
<h6 class="no_toc" id="tcp-vs-udp">
  
  
    <a href="#tcp-vs-udp" class="anchor-heading" aria-labelledby="tcp-vs-udp"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> TCP vs UDP
  
  
</h6>
    
<p>Latency sensitive applications (such as videoconferencing and VOIP) use UDP, which doesn’t perform flow control or resend lost packets. UDP is good in situations where delayed data is worthless.</p>
<h4 class="no_toc" id="synchronous-vs-asychronous-networks">
  
  
    <a href="#synchronous-vs-asychronous-networks" class="anchor-heading" aria-labelledby="synchronous-vs-asychronous-networks"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Synchronous vs. Asychronous Networks
  
  
</h4>
    
<p>A telephone network estabilishes a circuit, we say is synchronous even as the data passes through several routers as it does not suffer from queing. The maximum end-to-end latency of the network is fixed (bounded delay).</p>

<p>A circuit is a fixed amount of reserved bandwidth which nobody else can use while the circuit is established, whereas packets of a TCP connection opportunistically use whatever network bandwidth is available.</p>

<p>Using circuits for bursty data transfers wastes network capacity and makes transfer unnecessary slow. By contrast, TCP dinamycally adapts the rate of data transfer to the available network capacity.</p>

<p>We have to assume that network congestion, queueing, and unbounded delays will happen. Consequently, there’s no “correct” value for timeouts, they need to be determined experimentally.</p>
<h3 id="unreliable-clocks">
  
  
    <a href="#unreliable-clocks" class="anchor-heading" aria-labelledby="unreliable-clocks"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Unreliable Clocks
  
  
</h3>
    
<p>Time is tricky – sending messages is not instantaneous, and because of delays in networks, it is difficult to determine order things happened. Also, each machine has its own clock, which is typically a hardware device: a quartz crystal oscillator, which may run faster or slower than other clocks. One way around this is to synchronize time, e.g. as used in Network Time Protocol (NTP).</p>

<ul>
  <li>
<strong>time-of-day clocks</strong> - returns date and time according to some calendar (<em>wall-clock time</em>), and usually synced with NTP, which means if it is running faster than the server it might appear to jump back in time, meaning it isn’t suitable for <em>elapsed time</em> measurements.</li>
  <li>
<strong>monotonic clocks</strong> - good for measuring <em>duration</em>, as it is always guaranteed to move forward. The value of the monotonic clock is arbitrary (it might be time since computer turned on), making it impossible to compare monotonic clock values from two computers.</li>
</ul>
<h4 class="no_toc" id="clock-synchronization-and-accuracy">
  
  
    <a href="#clock-synchronization-and-accuracy" class="anchor-heading" aria-labelledby="clock-synchronization-and-accuracy"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Clock Synchronization and Accuracy
  
  
</h4>
    
<p>Quartz clocks in computers might <em>drift</em> (Google assumes clock drift of 17 seconds for a clock that is synchronized to NTP once a day). Also, a clock that is too different might refuse to sync.</p>

<p>Leap seconds result in time dilation – best way to deal is to <em>smear</em>, or spread out the difference over a whole day.</p>
<h4 class="no_toc" id="relying-on-synchronized-clocks">
  
  
    <a href="#relying-on-synchronized-clocks" class="anchor-heading" aria-labelledby="relying-on-synchronized-clocks"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Relying on Synchronized Clocks
  
  
</h4>
    
<p>Incorrect clocks often go unnoticed, so if clock drift would affect your processes, you must carefully monitor and declare dead any resources where the clock drifts too far afield.</p>
<h4 class="no_toc" id="timestamps-for-ordering-events">
  
  
    <a href="#timestamps-for-ordering-events" class="anchor-heading" aria-labelledby="timestamps-for-ordering-events"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Timestamps for Ordering Events
  
  
</h4>
    
<p><strong>It is tempting, but dangerous to rely on clocks for ordering of events across multiple nodes.</strong> This usually imply that <em>last write wins</em> (LWW), often used in both multi-leader replication and leaderless databases like Cassandra and Riak, and data-loss may happen.</p>

<p>The definition of “recent” also depends on local time-of-day clock, which may well be incorrect.</p>

<p><em>Logical clocks</em>, based on counters instead of oscillating quartz crystal, are safer alternative for ordering events. Logical clocks do not measure time of the day or elapsed time, only relative ordering of events. This contrasts with time-of-the-day and monotic clocks (also known as <em>physical clocks</em>).</p>
<h4 class="no_toc" id="clock-readings-have-a-confidence-interval">
  
  
    <a href="#clock-readings-have-a-confidence-interval" class="anchor-heading" aria-labelledby="clock-readings-have-a-confidence-interval"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Clock Readings Have a Confidence Interval
  
  
</h4>
    
<p>It doesn’t make sense to think of a clock reading as a point in time, it is more like a range of times, within a confidence internval: for example, 95% confident that the time now is between 10.3 and 10.5.</p>

<p>The most common implementation of snapshot isolation requires a monotonically increasing transaction ID.</p>

<p>Google’s Spanner implements snapshot isolation across datacenters by using clock’s confidence interval. If you have two confidence internvals where</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><div class="table-wrapper"><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td>
<td class="rouge-code"><pre>A = [A earliest, A latest]
B = [B earliest, B latest]
</pre></td>
</tr></tbody></table></div></code></pre></div></div>

<p>And those two intervals do not overlap (<code class="language-plaintext highlighter-rouge">A earliest</code> &lt; <code class="language-plaintext highlighter-rouge">A latest</code> &lt; <code class="language-plaintext highlighter-rouge">B earliest</code> &lt; <code class="language-plaintext highlighter-rouge">B latest</code>), then B definetively happened after A.</p>

<p>Spanner deliberately waits for the length of the confidence interval before commiting a read-write transaction, so their confidence intervals do not overlap.</p>

<p>Spanner needs to keep the clock uncertainty as small as possible, that’s why Google deploys a GPS receiver or atomic clock in each datacenter.</p>
<h4 class="no_toc" id="process-pauses">
  
  
    <a href="#process-pauses" class="anchor-heading" aria-labelledby="process-pauses"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Process Pauses
  
  
</h4>
    
<p>One method of determining leader in a leader-based system is for the leader to get a lease, and renew it periodically. This process might be flawed for several reasons:</p>
<ol>
  <li>garbage collection might stop processing while garbage is cleaned(<em>stop-the-world</em>)</li>
  <li>virtual machines can be suspended and resumed and this pause can last for an aribtrary length of time</li>
  <li>execution might be suspended when user suspends their session (closing laptop lid)</li>
  <li>when OS switches to another thread or hypervisor to another machine, threads can be paused (<em>steal time</em>)</li>
  <li>thread paused for disk access</li>
  <li>memory access resulting in page fault (thrashing, or spending most of its time swapping pages into and out of memory)</li>
  <li>unix process can be paused via <code class="language-plaintext highlighter-rouge">SIGSTOP</code>
</li>
</ol>

<p>Fairly good tools for making things thread-safe: mutexes, semaphores, atomic counters, lock-free data structures, blocking queues, etc. But these tools don’t translate to dsitributed system because there is no shared memory.</p>
<h5 class="no_toc" id="response-time-guarantees">
  
  
    <a href="#response-time-guarantees" class="anchor-heading" aria-labelledby="response-time-guarantees"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Response Time Guarantees
  
  
</h5>
    
<p>There are systems that require software to respond before a specific <em>deadline</em> (<em>real-time operating system, or RTOS</em>).</p>

<p>Library functions must document their worst-case execution times; dynamic memory allocation may be restricted or disallowed and enormous amount of testing and measurement must be done.</p>
<h5 class="no_toc" id="limiting-the-impact-of-garbage-collection">
  
  
    <a href="#limiting-the-impact-of-garbage-collection" class="anchor-heading" aria-labelledby="limiting-the-impact-of-garbage-collection"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Limiting the Impact of Garbage Collection
  
  
</h5>
    
<p>Garbage collection could be treated like brief planned outages. If the runtime can warn the application that a node soon requires a GC pause, the application can stop sending new requests to that node and perform GC while no requests are in progress.</p>

<p>A variant of this idea is to use the garbage collector only for short-lived objects and to restart the process periodically. For example, Instagram turned off Python’s garbage collection entirely to be more performant.</p>
<h3 class="no_toc" id="knowledge-and-truth-in-distributed-systems">
  
  
    <a href="#knowledge-and-truth-in-distributed-systems" class="anchor-heading" aria-labelledby="knowledge-and-truth-in-distributed-systems"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Knowledge and Truth in Distributed Systems
  
  
</h3>
    
<p>In a distributed system, we can state the assumptions we are making about the behavior (<em>system model</em>) of a system.</p>
<h4 class="no_toc" id="the-truth-is-defined-by-the-majority">
  
  
    <a href="#the-truth-is-defined-by-the-majority" class="anchor-heading" aria-labelledby="the-truth-is-defined-by-the-majority"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> The Truth is Defined by the Majority
  
  
</h4>
    
<p>Many distributed systems rely on <em>quorums</em>, or majority votes, to determine what the truth is, e.g., whether a node is dead. There can only be one majority at a time.</p>
<h5 class="no_toc" id="fencing-tokens">
  
  
    <a href="#fencing-tokens" class="anchor-heading" aria-labelledby="fencing-tokens"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Fencing Tokens
  
  
</h5>
    
<p>We need to ensure that a node that is under a false belief of being “the chosen one” cannot disrupt the rest of the system</p>

<p><em>fencing token</em> - a monotonically increasing token that a client needs to include to a write to a data system, which should prevent undetected lease expiry.</p>
<h4 class="no_toc" id="byzantine-faults">
  
  
    <a href="#byzantine-faults" class="anchor-heading" aria-labelledby="byzantine-faults"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Byzantine Faults
  
  
</h4>
    
<p><em>byzantine fault</em> - is a condition of a computer system, particularly distributed computing systems, where components may fail and there is imperfect information on whether a component has failed.</p>

<p><strong>Byzantine General Problem</strong></p>
<blockquote>
  <p>In its simplest form, the generals must decide only whether to attack or retreat. Some generals may prefer to attack, while others prefer to retreat. The important thing is that every general agree on a common decision, for a halfhearted attack by a few generals would become a rout, and would be worse than either a coordinated attack or a coordinated retreat.</p>

  <p>The problem is complicated by the presence of treacherous generals who may not only cast a vote for a suboptimal strategy, they may do so selectively. For instance, if nine generals are voting, four of whom support attacking while four others are in favor of retreat, the ninth general may send a vote of retreat to those generals in favor of retreat, and a vote of attack to the rest. Those who received a retreat vote from the ninth general will retreat, while the rest will attack (which may not go well for the attackers). The problem is complicated further by the generals being physically separated and having to send their votes via messengers who may fail to deliver votes or may forge false votes.</p>
</blockquote>
<h2 id="chapter-summary-7">
  
  
    <a href="#chapter-summary-7" class="anchor-heading" aria-labelledby="chapter-summary-7"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Chapter Summary
  
  
</h2>
    
<ul>
  <li>Whenever you try to send a packet over the network, it may be lost or arbitrarily delayed. Likewise, the reply may be lost or delayed, so if you don’t get a reply,you have no idea whether the message got through.</li>
  <li>A node’s clock may be significantly out of sync with other nodes (despite your best efforts to set up NTP), it may suddenly jump forward or back in time, and relying on it is dangerous because you most likely don’t have a good measure ofyour clock’s error interval.</li>
  <li>A process may pause for a substantial amount of time at any point in its execu‐tion (perhaps due to a stop-the-world garbage collector), be declared dead byother nodes, and then come back to life again without realizing that it waspaused.</li>
</ul>

<p>The fact that such partial failures can occur is the defining characteristic of distributed systems. Whenever software tries to do anything involving other nodes,there is the possibility that it may occasionally fail, or randomly go slow, or not respond at all (and eventually time out). In distributed systems, we try to build tolerance of partial failures into software, so that the system as a whole may continue functioning even when some of its constituent parts are broken.</p>

<p>To tolerate faults, the first step is to detect them, but even that is hard. Most systems don’t have an accurate mechanism of detecting whether a node has failed, so most distributed algorithms rely on timeouts to determine whether a remote node is still available. However, timeouts can’t distinguish between network and node failures,and variable network delay sometimes causes a node to be falsely suspected of crash‐ing. Moreover, sometimes a node can be in a degraded state: for example, a Gigabit network interface could suddenly drop to 1 Kb/s throughput due to a driver bug.Such a node that is “limping” but not dead can be even more difficult to deal with than a cleanly failed node.</p>

<p>Once a fault is detected, making a system tolerate it is not easy either: there is no global variable, no shared memory, no common knowledge or any other kind of shared state between the machines. Nodes can’t even agree on what time it is, let alone on anything more profound. The only way information can flow from one node to another is by sending it over the unreliable network. Major decisions cannot be safely made by a single node, so we require protocols that enlist help from other nodes and try to get a quorum to agree.</p>

<p>If you’re used to writing software in the idealized mathematical perfection of a single computer, where the same operation always deterministically returns the same result,then moving to the messy physical reality of distributed systems can be a bit of a shock. Conversely, distributed systems engineers will often regard a problem as trivial if it can be solved on a single computer, and indeed a single computer can do a lot nowadays. If you can avoid opening Pandora’s box and simply keep things on a single machine, it is generally worth doing so.</p>

<p>However, as discussed in the introduction to Part II, scalability is not the only reason for wanting to use a distributed system. Fault tolerance and low latency (by placing data geographically close to users) are equally important goals, and those things can‐not be achieved with a single node.</p>

<p>Whether the unreliability of networks, clocks, and processes is an inevitable law of nature. We saw that it isn’t: it is possible to give hard real-time response guarantees and bounded delays in net‐works, but doing so is very expensive and results in lower utilization of hardware resources. Most non-safety-critical systems choose cheap and unreliable over expensive and reliable.</p>

<p>Also supercomputers, which assume reliable components and thus have to be stopped and restarted entirely when a component does fail. By contrast,distributed systems can run forever without being interrupted at the service level,because all faults and maintenance can be handled at the node level—at least in theory. (In practice, if a bad configuration change is rolled out to all nodes, that will still bring a distributed system to its knees.)</p>
<h1 id="chapter-9-consistency-and-consensus">
  
  
    <a href="#chapter-9-consistency-and-consensus" class="anchor-heading" aria-labelledby="chapter-9-consistency-and-consensus"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Chapter 9: Consistency and Consensus
  
  
</h1>
    
<p><strong>consensus</strong> - An important abstraction in distributed systems which means getting the nodes to all agree on something. This can be a tricky problem in the presence of network faults and process failures.</p>
<h2 id="consistency-guarantees">
  
  
    <a href="#consistency-guarantees" class="anchor-heading" aria-labelledby="consistency-guarantees"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Consistency Guarantees
  
  
</h2>
    
<p>When you look at two database nodes at the same time, you might see different data because write requests arrive to nodes at different times.</p>

<p>Most databases provide <em>eventual consistency</em>, or the idea that if you stop writing and wait an unspecified amount of time, all reads will return the same value. This might also be called <em>convergence</em>.</p>

<p>Transactions are not the same as distributed consistency models: transaction isolation is primarily about avoiding race conditions due to concurrently executing transactions, whereas distributed consistency is mostly about coordinating the state of replicats in the face of delays and faults.</p>
<h2 id="linearizability">
  
  
    <a href="#linearizability" class="anchor-heading" aria-labelledby="linearizability"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Linearizability
  
  
</h2>
    
<p><strong>linearizability</strong> (aka <em>atomic consistency</em>, <em>strong consistency</em>, <em>immediate consistency</em>, <em>external consistency</em>) - A <em>recency guarantee</em> that a system appears as if there is only one copy of the data even if there are many, and all operations are atomic.</p>
<h3 class="no_toc" id="what-makes-a-system-linearizable">
  
  
    <a href="#what-makes-a-system-linearizable" class="anchor-heading" aria-labelledby="what-makes-a-system-linearizable"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> What Makes a System Linearizable?
  
  
</h3>
    
<p>In linearizable systems there must be some point in time at which the value for a <em>register</em> (a single object, as in a key:value, a row, a document) must atomically switch from old value to new, and if one read returns the new value, all subsequent reads must return the new value.</p>

<p>three operations:</p>
<ul>
  <li>
<code class="language-plaintext highlighter-rouge">read(x) =&gt; v</code> read from register <code class="language-plaintext highlighter-rouge">x</code>, return value <code class="language-plaintext highlighter-rouge">v</code>
</li>
  <li>
<code class="language-plaintext highlighter-rouge">write(x, v) =&gt; r</code> client requests to set register <code class="language-plaintext highlighter-rouge">x</code> to <code class="language-plaintext highlighter-rouge">v</code> and returns response <code class="language-plaintext highlighter-rouge">r</code>
</li>
  <li>
<code>cas(x, v<sub>old</sub>, v<sub>new</sub>) =&gt; r</code> an atomic compare-and-set operation. If the value of the register x equals v_old, it is atomically set to v_new. If x != v_old the registers is unchanged and it returns an error</li>
</ul>

<p><strong>serializability</strong> - is an isolation property of transactions where every transaction may read or write multiple objects, and guarantees that transactions behave as if they were executed in <em>some</em> serial order</p>

<p><strong>linearizability</strong> - a recency guarantee on reads and writes of a register (single object), so it doesn’t prevent problems such as write skew</p>

<p><em>strict serializability</em> (aka <em>strong one-copy serializability</em>) - database provides both linearizability and serializability</p>
<h3 class="no_toc" id="relying-on-linearizability">
  
  
    <a href="#relying-on-linearizability" class="anchor-heading" aria-labelledby="relying-on-linearizability"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Relying on Linearizability
  
  
</h3>
    
<p>Some systems require linearizability:</p>

<ul>
  <li>
<em>locking and leader election</em> - To ensure that there is indeed only one leader, a lock is used. It must be linearizable: all nodes must agree which nodes owns the lock; otherwise its useless. Apache Zookeeper and etcd are often used for distributed locks and leader election.</li>
  <li>
<em>constraints and uniqueness guarantees</em> - in order to enforce uniqueness, system needs to be linearizable</li>
  <li>
<em>cross-channel timing dependencies</em> - if there are multiple communication channels for messages and data to travel, there might be a race condition between those two channels (think message queue and file system writes)</li>
</ul>
<h3 class="no_toc" id="implementing-linearizable-systems">
  
  
    <a href="#implementing-linearizable-systems" class="anchor-heading" aria-labelledby="implementing-linearizable-systems"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Implementing Linearizable Systems
  
  
</h3>
    
<p>Simplest approach would be to only have a single copy of the data, but that system wouldn’t tolerate faults. The most common approach to making a system fault-tolerant is to use replication.</p>

<p><strong>single-leader replication</strong> (potentially linearizable) - if you make reads from the leader or synchronously updated followers, they have the potential to be <em>linearizable</em>, unless using snapshot isolation or due to bugs</p>

<p><strong>consensus algorithms</strong> (linearizable) - bear a resemblance to single-leader, but prevent split brain and stale replicas</p>

<p><strong>multi-leader replication</strong> (not linearizable) - concurrently process writes on multiple nodes and asynchronously replicate</p>

<p><strong>leaderless replication</strong> (probably not linearizable) - last write wins based on time of day clocks and sloppy quorums prevent linearizability</p>
<h3 class="no_toc" id="the-cost-of-linearizability">
  
  
    <a href="#the-cost-of-linearizability" class="anchor-heading" aria-labelledby="the-cost-of-linearizability"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> The Cost of Linearizability
  
  
</h3>
    
<h4 class="no_toc" id="the-cap-theorem">
  
  
    <a href="#the-cap-theorem" class="anchor-heading" aria-labelledby="the-cap-theorem"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> The CAP Theorem
  
  
</h4>
    
<p>In the presence of network partitions (faults/interruptions), your application can either be available (but might serve nonlinearizable/stale reads) or consistent (linearizable but would send errors instead of stale data). Applications that don’t need to be linearizable have a higher tolerance for consistency and availability in the presence of network partitions.</p>

<p>Defined by Eric Brewer in 2000 as a rule of thumb, the definitions of high availability (fault tolerance) can be misleading, and CAP theorem is best avoided, although it has been historically influential and led to explosion in alternate data storage models (NoSQL).</p>
<h4 class="no_toc" id="linearizability-and-network-delays">
  
  
    <a href="#linearizability-and-network-delays" class="anchor-heading" aria-labelledby="linearizability-and-network-delays"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Linearizability and Network Delays
  
  
</h4>
    
<p>Even RAM on a modern multi-core CPU is not linearizable.</p>

<p>The reason for dropping linearizability is performance, not <em>fault-tolerance</em>.</p>

<p>Response time for read and write requests is at least proportional to the uncertainty of network delays in the network, so a faster algorithm for linearizability doesn’t exist, but weaker consistency models can be much faster.</p>
<h2 id="ordering-guarantees">
  
  
    <a href="#ordering-guarantees" class="anchor-heading" aria-labelledby="ordering-guarantees"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Ordering Guarantees
  
  
</h2>
    
<p>Ordering is a very important concept, e.g., main purpose of leader is to determine order of writes in replication log, serializability is ensuring writes in <em>some sequential order</em>, and use of timestamps is an attempt to introduce order.</p>
<h3 class="no_toc" id="ordering-and-causality">
  
  
    <a href="#ordering-and-causality" class="anchor-heading" aria-labelledby="ordering-and-causality"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Ordering and Causality
  
  
</h3>
    
<p>Order helps preserve causality. If a system obeys the ordering imposed by causality, it is <em>causally consistent</em>.</p>
<h4 class="no_toc" id="the-causal-order-is-not-a-total-order">
  
  
    <a href="#the-causal-order-is-not-a-total-order" class="anchor-heading" aria-labelledby="the-causal-order-is-not-a-total-order"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> The causal order is not a total order
  
  
</h4>
    
<p>A <em>total order</em> allows any two elements to be compared (e.g., natural numbers 2&lt;3). Math sets (e.g., {a, b}, {c, d}) are incomparable, or <em>partially ordered</em>.</p>

<p>In linearizable systems, we have <em>total order</em> of operations based on timing, but causality defines <em>partial order</em>, as two events are incomparable if they are concurrent.</p>
<h4 class="no_toc" id="linearizability-is-stronger-than-causal-consistency">
  
  
    <a href="#linearizability-is-stronger-than-causal-consistency" class="anchor-heading" aria-labelledby="linearizability-is-stronger-than-causal-consistency"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Linearizability is stronger than causal consistency
  
  
</h4>
    
<p>Linearizability implies causality, but many systems that seem to require linearizability only need causal consistency. Causal consistency is the strongest consistency model that does not slow down due to network delays and remains available during network delays.</p>

<p>In order to determine the causal ordering, the database needs to know which version of the data was read by the application. The version number from the prior operation is passed back to the database on a write.</p>

<p>We can create sequence numbers in a total order that is consistent with causality.</p>

<p>With a single-leader replication, the leader can simply increment a counter for each operation, and thus assign a monotonically increasing sequence number to each operation in the replication log.</p>

<p>If there is not a single leader (multi-leader or leaderless database):</p>

<p>Each node can generate its own independent set of sequence numbers. One node can generate only odd numbers and the other only even numbers.
Attach a timestamp from a time-of-day clock.
Preallocate blocks of sequence numbers.
The only problem is that the sequence numbers they generate are not consistent with causality. They do not correctly capture ordering of operations across different nodes.</p>

<p>There is simple method for generating sequence numbers that is consistent with causality: Lamport timestamps.</p>

<p>Each node has a unique identifier, and each node keeps a counter of the number of operations it has processed. The lamport timestamp is then simply a pair of (counter, node ID). It provides total order, as if you have two timestamps one with a greater counter value is the greater timestamp. If the counter values are the same, the one with greater node ID is the greater timestamp.</p>

<p>Every node and every client keeps track of the maximum counter value it has seen so far, and includes that maximum on every request. When a node receives a request of response with a maximum counter value greater than its own counter value, it inmediately increases its own counter to that maximum.</p>

<p>As long as the maximum counter value is carried along with every operation, this scheme ensure that the ordering from the lamport timestamp is consistent with causality.</p>

<p>Total order of oepration only emerges after you have collected all of the operations.</p>
<h4 class="no_toc" id="total-order-broadcast">
  
  
    <a href="#total-order-broadcast" class="anchor-heading" aria-labelledby="total-order-broadcast"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Total Order Broadcast
  
  
</h4>
    
<p><em>total order broadcast</em> - the problem of how to handle total order of operations in distributed systems where the throughput is more than a single leader can handle, or failover needs to happen.</p>

<p>Total order broadcast is usually described as a protocol for exchanging messages between two nodes, and it requires that two safety properties always be satisfied:</p>
<ol>
  <li>
<em>reliable delivery</em> - no message is lost: if a message is delivered to one node it is deliverd to all nodes</li>
  <li>
<em>totally ordered delivery</em> - messages are delivered to every node in the same order</li>
</ol>

<p><em>state machine replication</em> - if every message represents a write to the database, and every replica processes the same writes in the same order then all replicas witll remain consistent with each other.</p>
<h2 id="distributed-transactions-and-consensus">
  
  
    <a href="#distributed-transactions-and-consensus" class="anchor-heading" aria-labelledby="distributed-transactions-and-consensus"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Distributed Transactions and Consensus
  
  
</h2>
    
<p>Generally, the goal of consensus is to get several nodes to agree to something. Some examples where nodes need to agree:</p>
<ul>
  <li>
<em>leader election</em> - deciding which node is the leader in single-leader replication schemes</li>
  <li>
<em>atomic commit</em> - in database that supports transactions across several nodes or parititons, a transaction might fail on some nodes and not others</li>
</ul>

<blockquote>
  <p><strong>FLP Result</strong> - maintains that there is no algorithm that is always able to reach a consensus if there is a risk that a node might crash, but consensus is solvable if allowed to use timeouts.</p>
</blockquote>
<h3 class="no_toc" id="atomic-commit-and-two-phase-commit-2pc">
  
  
    <a href="#atomic-commit-and-two-phase-commit-2pc" class="anchor-heading" aria-labelledby="atomic-commit-and-two-phase-commit-2pc"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Atomic Commit and Two-Phase Commit (2PC)
  
  
</h3>
    
<p>In a single node database, it is a single device, the controller of a particular disk drive, that makes a commit atomic.</p>

<p>For multiple nodes, you can’t send the commit request to everyone and hope that things succeed – some might fail, causing nodes to become inconsistent.</p>

<p><em>two-phase commit</em> is the algorithm for achieving atomic transactions across multiple nodes.</p>

<p><em>coordinator</em> (aka <em>transaction manager</em>) queries <em>participants</em> (database nodes) with a <em>prepare</em> request. All nodes need to reply that they are ready to commit. If any participant says no, the commit fails.</p>

<p>The process:</p>
<ol>
  <li>application requests a globally unique transaction ID from the coordinator</li>
  <li>application begins a single node transaction</li>
  <li>when the application is ready to commit, the coordinator sends prepare requests (with transaction id)</li>
  <li>participants ensure they can commit</li>
  <li>when coordinator has received all responses, it makes a decision</li>
  <li>once coordinator’s decision is written to disk, the commit or abort is sent to all participants – if any participants time out, the coordinator must try forever until success.</li>
</ol>
<h4 class="no_toc" id="coordinator-failure">
  
  
    <a href="#coordinator-failure" class="anchor-heading" aria-labelledby="coordinator-failure"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> coordinator failure
  
  
</h4>
    
<p>If the coordinator fails before sending the prepare requests, then the transaction is aborted. But if it fails after committing but before sending the confirmation, participants are <em>in doubt</em> or <em>uncertain</em>, and the coordinator must recover for the 2PC to work.</p>
<h4 class="no_toc" id="three-phase-commit">
  
  
    <a href="#three-phase-commit" class="anchor-heading" aria-labelledby="three-phase-commit"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> three-phase commit
  
  
</h4>
    
<p>A two-phase commit is called a <em>blocking</em> atomic commit protocol because it might get stuck on coordinator. A nonblocking atomic commit requires a <em>perfect failure detector</em>, aka a reliable mechanism to detect whether a node has crashed or not.</p>
<h3 class="no_toc" id="distributed-transactions-in-practice">
  
  
    <a href="#distributed-transactions-in-practice" class="anchor-heading" aria-labelledby="distributed-transactions-in-practice"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Distributed Transactions in Practice
  
  
</h3>
    
<p>Some implementations of 2PC carry heavy performance penalty (MySQL reported to be 10 times slower than single-node transactions)</p>

<p>There are two different types of distributed transactions:</p>
<ol>
  <li>
<em>database-internal distributed transactions</em>, where transaction is internal to nodes of a database all running the same software, and these can work very well</li>
  <li>
<em>heterogeneous distributed transactions</em>, where participants are two or more technlogies – these are much less performant</li>
</ol>
<h4 class="no_toc" id="exactly-once-message-processing">
  
  
    <a href="#exactly-once-message-processing" class="anchor-heading" aria-labelledby="exactly-once-message-processing"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> exactly-once message processing
  
  
</h4>
    
<p>Message brokers leverage this atomic commit to ensure that a message is only delivered once, and any failures are aborted. Thus we can ensure a message is <em>effectively</em> processed only once.</p>
<h4 class="no_toc" id="xa-transactions">
  
  
    <a href="#xa-transactions" class="anchor-heading" aria-labelledby="xa-transactions"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> XA transactions
  
  
</h4>
    
<p><em>X/Open XA</em> (<em>Extended Architecture</em>) is a standard for implementing two-phase commit across heterogeneous technologies. It is a C API.</p>

<p>XA assumes that application uses a network driver or client library to communicate with downstream consumers, and leverages that to ensure atomic commits. Commits/aborts are saved to the local disk where the 2PC is coordinated, so if that server dies, it needs to be restarted if participants are in doubt.</p>
<h4 class="no_toc" id="holding-locks-when-in-doubt">
  
  
    <a href="#holding-locks-when-in-doubt" class="anchor-heading" aria-labelledby="holding-locks-when-in-doubt"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> holding locks when in doubt
  
  
</h4>
    
<p>The reason we can’t ignore participants <em>in doubt</em> is because of locking. Databases typically take a row level exclusive lock on any row they update, and won’t release until the transaciton commits or aborts, and depending on the database other transactions may be blocked from reading.</p>
<h4 class="no_toc" id="recovering-from-coordinator-failure">
  
  
    <a href="#recovering-from-coordinator-failure" class="anchor-heading" aria-labelledby="recovering-from-coordinator-failure"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> recovering from coordinator failure
  
  
</h4>
    
<p>Typically, coordinators resume and clean up any in doubt participants, but sometimes, there are <em>orphaned</em> in doubt participants because the coordinator didn’t resume cleanly.</p>

<p>Only way to clean up is for the administrator to manually clean up.</p>
<h4 class="no_toc" id="limitations-of-distributed-transactions">
  
  
    <a href="#limitations-of-distributed-transactions" class="anchor-heading" aria-labelledby="limitations-of-distributed-transactions"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> limitations of distributed transactions
  
  
</h4>
    
<p>Coordinators themselves are like a database and represent a single point of failure, and many coordinator implementations aren’t highly available by default.</p>

<p>Many applications are stateless (as preferred by HTTP), but coordinators are typically implemented in the application code and thus change that calculus.</p>

<p>XA needs to be compatible with many data systems and is thus a lowest common denominator incapable of dealing with specialized problems like deadlocks.</p>

<p>Distributed transactions have a tendency of amplifying failure.</p>
<h3 class="no_toc" id="fault-tolerant-consensus">
  
  
    <a href="#fault-tolerant-consensus" class="anchor-heading" aria-labelledby="fault-tolerant-consensus"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Fault-Tolerant Consensus
  
  
</h3>
    
<p>Consensus can be framed like one or more node <em>proposes</em> values, and the consensus algorithm <em>decides</em> on values. For <em>uniform consensus</em>, you need:</p>
<ul>
  <li>
<em>uniform agreement</em> - no two nodes decide differently</li>
  <li>
<em>integrity</em> - no node decides twice</li>
  <li>
<em>validity</em> - nodes can only decide on values proposed</li>
  <li>
<em>termination</em> - every node that doesn’t crash immediately decides on values</li>
</ul>

<p>The best-known fault-tolerant consensus algorithms (Viewstamped Replication, Paxos, Raft, and Zab), agree on a sequence of events instead of the uniform consensus above, and are thus total broadcast algorithms. Total order broadcast requires messages to be delivered exactly once, in the same order, to all nodes.</p>

<p>So total order broadcast is equivalent to repeated rounds of consensus:</p>
<ul>
  <li>Due to agreement property, all nodes decide to deliver the same messages in the same order.</li>
  <li>Due to integrity, messages are not duplicated.</li>
  <li>Due to validity, messages are not corrupted.</li>
  <li>Due to termination, messages are not lost.</li>
</ul>
<h4 class="no_toc" id="limitations-of-consensus">
  
  
    <a href="#limitations-of-consensus" class="anchor-heading" aria-labelledby="limitations-of-consensus"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> limitations of consensus
  
  
</h4>
    
<p>The process by which nodes vote on proposals before they are decided is a kind of synchronous replication, which is often less than ideal.</p>

<p>Many consensus algorithms assume a fixed set of nodes to participate in voting so unless you have <em>dynamic membership</em> or can’t add nodes without changing the algorithm.</p>

<p>Consensus systems rely on timeouts to detect failed nodes, but in systems with high latency (geopgraphically distributed systems) nodes falsely think leader has failed.</p>

<p>Consensus algorithms are also sensitive to network delays, where leaders bounce from leader to dead frequently.</p>
<h3 class="no_toc" id="membership-and-coordination-services">
  
  
    <a href="#membership-and-coordination-services" class="anchor-heading" aria-labelledby="membership-and-coordination-services"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Membership and Coordination Services
  
  
</h3>
    
<p>Zookeeper and etcd are described as “distributed key-value stores” or “coordination and configuration services”.</p>

<p>They are rarely consumed directly, but HBase, Hadoop YARN, OpenStack Nova, and Kafka rely on them in the background.</p>

<p>Zookeeper based on Google’s Chubby lock service, and implements the following features which makes it suited for distributed coordination:</p>
<ul>
  <li><em>linearizable atomic operations</em></li>
  <li><em>total ordering of operations</em></li>
  <li><em>failure detection</em></li>
  <li><em>change notifications</em></li>
</ul>

<p>Zookeeper, etcd, and Consul are used for <em>service discovery</em>, to find out which IP address you need to connect to to reach a particular service, but DNS is also typically used for this purpose.</p>

<p>These services also can be used as <em>membership services</em>, which determines which node is alive and which isn’t.</p>
<h2 id="chapter-summary-8">
  
  
    <a href="#chapter-summary-8" class="anchor-heading" aria-labelledby="chapter-summary-8"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Chapter Summary
  
  
</h2>
    
<p>Linearizability is a popular consistency model – its goal is to make replicated data appear as if there is only a single copy, and to make all operations on it atomic. This makes databases work like a variable in a single-threaded application, which makes it slow, especially in environments with large network delays.</p>

<p>Causality is a weaker consistency model than linearizability that just needs to respect cause and effect ordering, like a version history timeline with branching and merging. Causal consistency does not have coordination overhead of linearizability and is less sensitive to network problems. With causal consistency, there might still be problems with concurrent writes and uniqueness, so consensus might be required.</p>

<p>Consensus requires all nodes to agree, and that agreement is irrevocable. There are many problems that can be reduced to consensus:</p>
<ul>
  <li>
<em>linearizable compare-and-set registers</em> - the register needs to atomically decide whether to set its value based on whether its current value equals the parameter given in the operation</li>
  <li>
<em>atomic transaction commit</em> - a database must decide whetehr to commit or abort a distributed transaction</li>
  <li>
<em>total order broadcast</em> - the messaging system must decide on the order in which to deliver messages</li>
  <li>
<em>locks and leases</em> - when several clients try to get lease/lock, the lock decides which one successfully acquired it</li>
  <li>
<em>membership/coordination service</em> - given a failure detector (timeouts) the system must decide which nodes are alive and which are dead because their session timed out</li>
  <li>
<em>uniqueness constraint</em> - constraint must decide which write to allow and which should fail constraint violation</li>
</ul>

<p>In a single-leader database or a single node, these are easy. All power is in that single leader or single node.</p>

<p>If leader fails, there are three ways to handle that problem:</p>
<ol>
  <li>wait for the leader to recover</li>
  <li>manually fail over by choosing a new leader node</li>
  <li>use an algorithm to automatically choose a new leader</li>
</ol>

<p>In a single-leader node, you don’t need consensus on every write, but you do need it to choose a new leader.</p>

<p>Tools like Zookeeper provide “outsourced” consensus, failure detection, and membership services. It is hard to use but easier than writing your own.</p>

<p>Leaderless and multi-leader do not need global consensus.</p>
<h1 id="chapter-10-batch-processing">
  
  
    <a href="#chapter-10-batch-processing" class="anchor-heading" aria-labelledby="chapter-10-batch-processing"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Chapter 10: Batch Processing
  
  
</h1>
    
<p>Three types of systems:</p>
<ol>
  <li>
<em>services (online systems)</em> - a service waits for a request, and then sends back a response. usually, response time and availability are highest concern</li>
  <li>
<em>batch processing systems (offline systems)</em> - batch processing job takes a fixed set of a large amount of data, runs a job to process it, and produces output data. these are typically scheduled, and throughput is highest concern.</li>
  <li>
<em>stream processing (near-real-time systems)</em> - between a batch and a service. like a batch processor, it takes inputs and creates outputs, but does not operate on a fixed set of data but rather responds to events. this allows stream processing to have lower latency than batch processing.</li>
</ol>

<p>Batch processing has existed for a while – the Holerith machines made for the 1890 US census used a similar idea.</p>
<h2 id="batch-processing-with-unix-tools">
  
  
    <a href="#batch-processing-with-unix-tools" class="anchor-heading" aria-labelledby="batch-processing-with-unix-tools"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Batch Processing with Unix Tools
  
  
</h2>
    
<p>We can build a unix pipeline to process log files</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><div class="table-wrapper"><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td>
<td class="rouge-code"><pre><span class="nb">cat</span> /var/log/nginx/access.log | <span class="c"># read the log file</span>
  <span class="nb">awk</span> <span class="s1">'{print $7}'</span> | <span class="c"># split each line into fields by whitespace and output the seventh field</span>
  <span class="nb">sort</span>             | <span class="c"># alphabetically sort</span>
  <span class="nb">uniq</span> <span class="nt">-c</span>          | <span class="c"># filters repeated lines, and the -c is for a counter</span>
  <span class="nb">sort</span> <span class="nt">-r</span> <span class="nt">-n</span>       | <span class="c"># sorts by number at the beginning (-c from above) then returns in reverse order -r</span>
  <span class="nb">head</span> <span class="nt">-n</span> 5        | <span class="c"># outputs the first five lines (-n 5) and discards the rest</span>
</pre></td>
</tr></tbody></table></div></code></pre></div></div>
<p>Many data analyses can be performed with a combination of <code class="language-plaintext highlighter-rouge">awk</code>, <code class="language-plaintext highlighter-rouge">sed</code>, <code class="language-plaintext highlighter-rouge">grep</code>, <code class="language-plaintext highlighter-rouge">sort</code>, <code class="language-plaintext highlighter-rouge">uniq</code>, and <code class="language-plaintext highlighter-rouge">xargs</code>.</p>

<p>Choosing whether to sort in memory or spill over to disk is a matter of the size of your data set. The GNU <code class="language-plaintext highlighter-rouge">sort</code> functionality has the ability to spill over to disk for larger than memory datasets.</p>
<h3 class="no_toc" id="the-unix-philosophy">
  
  
    <a href="#the-unix-philosophy" class="anchor-heading" aria-labelledby="the-unix-philosophy"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> The Unix Philosophy
  
  
</h3>
    
<p>Chaining commands together like connecting pipes together to achieve a goal via <em>composition</em>.</p>

<p>Described by Doug McIlroy:</p>
<ol>
  <li>Make each program do one thing well. To do a new job, build afresh rather than complicate old programs by adding new “features”.</li>
  <li>Expect the output of every program to become the input to another, as yet unknown, program. Don’t clutter output with extraneous information. Avoid stringently columnar or binary input formats. Don’t insist on interactive input.</li>
  <li>Design and build software, even operating systems, to be tried early, ideally within weeks. Don’t hesitate to throw away the clumsy parts and rebuild them.</li>
  <li>Use tools in preference to unskilled help to lighten a programming task, even if you have to detour to build the tools and expect to throw some of them out after you’ve finished using them.</li>
</ol>

<p>There is a direct line to Agile and DevOps – automation, rapid prototyping, incremental iteration, being friendly to experimentation, and breaking down large projects into manageable chunks.</p>
<h4 class="no_toc" id="a-uniform-interface">
  
  
    <a href="#a-uniform-interface" class="anchor-heading" aria-labelledby="a-uniform-interface"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> A uniform interface
  
  
</h4>
    
<p>When you assume that any programs output could become any programs input, all programs need to use the same input/output interface.</p>

<p>In Unix, that interface is a file/file descriptor (Unix - everything is a file). A file is just an ordered sequence of bytes, and many things can be represented via that interface.</p>

<p>By convention, many (but not all) treat a sequence of bytes as ASCII text.</p>

<p>The unix approach works best if a program simply uses <code class="language-plaintext highlighter-rouge">stdin</code> and <code class="language-plaintext highlighter-rouge">stdout</code>. This allows a shell user to wire up the input and output in whatever way they want; the program doesn’t know or care where the input is coming from and where the output is going to.</p>
<h2 id="mapreduce-and-distributed-filesystems">
  
  
    <a href="#mapreduce-and-distributed-filesystems" class="anchor-heading" aria-labelledby="mapreduce-and-distributed-filesystems"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> MapReduce and Distributed Filesystems
  
  
</h2>
    
<p>Like Unix tools, MapReduce normally doesn’t modify input and doesn’t have side effects other than producing output. Instead of <code class="language-plaintext highlighter-rouge">stdin</code> and <code class="language-plaintext highlighter-rouge">stdout</code>, MapReduce reads and writes on a distributed filesystem. In Hadoop’s version of MapReduce, the distributed file system is called Haddop Distributed File System (HDFS).</p>

<p>HDFS is based on a shared-nothing architecture, in contrast to Network Attached Storage (NAS) or Storage Area Network (SAN) architectures. Shared disk storage is implemented via a centralized hardware, whereas distributed systems does not require special hardware and communicates via network. A daemon is runnign on each machine, and a central server called a <em>NameNode</em> keeps track of what is written where. File blocks are replicated on several machines.</p>

<p>MapReduce jobs look like the Unix example above:</p>
<ol>
  <li>read input and break up into records</li>
  <li>call <em>mapper</em> to extrace key-value pairs</li>
  <li>sort all key-value pairs by key</li>
  <li>call the <em>reducer</em> function to iterate over those key-values</li>
</ol>

<ul>
  <li>
<strong>mapper</strong> - called once per record and it extracts one or many key-value pairs from a record. it does not retain state.</li>
  <li>
<strong>reducer</strong> - given all the values belonging to the same key and iterates over that collection (for aggregations, say)</li>
</ul>

<p>MapReduce allows you to parallelize acros many machines. You can write mappers and reducers in conventional programming languages. For Hadoop, its Java. For MongoDB and CouchDB, its Javascript.</p>

<p>MapReduce tries to run each mapper on machine that holds the data, or, <em>putting the computation near the data</em>, which saves expensive network latency and increases locality.</p>
<h3 class="no_toc" id="mapreduce-workflows">
  
  
    <a href="#mapreduce-workflows" class="anchor-heading" aria-labelledby="mapreduce-workflows"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> MapReduce Workflows
  
  
</h3>
    
<p>Range of problems that can be solved by a single map job is limited, so often MapReduce jobs are chained together in <em>workflows</em>. Unlike Unix, which uses in-memory buffers to pass between commands, workflows persist to the filesystem (<em>materializing intermediary state</em>).</p>

<p>There are then dependencies between job executions, so workflow schedulers for Hadoop, like Oozie, Azkaban, Luigi, Airflow, and Pinball, have been developed.</p>

<p>Also, higher-level tools for Hadoop, like Pig, Hive, Cascading Crunch, and FlumeJava set up workflows of MapReduce.</p>
<h3 class="no_toc" id="reduce-side-joins-and-grouping">
  
  
    <a href="#reduce-side-joins-and-grouping" class="anchor-heading" aria-labelledby="reduce-side-joins-and-grouping"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Reduce-Side Joins and Grouping
  
  
</h3>
    
<h4 class="no_toc" id="joins-and-sort-merges">
  
  
    <a href="#joins-and-sort-merges" class="anchor-heading" aria-labelledby="joins-and-sort-merges"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> joins and sort merges
  
  
</h4>
    
<p>Many datasets have an association with another record (<em>foreign key</em> in relational, <em>document reference</em> in document, <em>edge</em> in graph), and a join is needed if some code needs to access both record and its reference, and in a database you would use an index to quickly locate records. MapReduce has no concept of index as such.</p>

<p>MapReduce jobs scan the entire contents of the files (a database would call this a <em>full table scan</em>, and this is very expensive), but MapReduce typically would be calculating aggregates across the full data set (like an analytic query), so this full scan is reasonable.</p>

<p>For example, you might have clickstream data with just a user id, but you want to pull date of birth as well, and that only exists in a user database. You want to keep computation local to one machine to achieve good throughput for batch processing, so making random access queries for each record is not performant. One approach would be to pull the user database into a set of files and put it on the HDFS. Then, the output can be sort-merged to be in a single place.</p>

<p>MapReduce has separated the physical network communication aspects (getting the data to the right machine) fropm the application logic (processing the data once you have it). By handling network, it also insulates application code from handling partial failures; MapReduce transparently retries failed tasks.</p>
<h4 class="no_toc" id="group-by">
  
  
    <a href="#group-by" class="anchor-heading" aria-labelledby="group-by"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> group by
  
  
</h4>
    
<p>Another pattern of bringing data together is grouping (<code class="language-plaintext highlighter-rouge">GROUP BY</code> in SQL), e.g., counting the number of records in a group, adding up the records in a particular field, or picking the top <em>n</em> records given a ranking function. Grouping looks very similar to joining in process, as it relies on the sorting of identical keys.</p>
<h4 class="no_toc" id="handling-skew">
  
  
    <a href="#handling-skew" class="anchor-heading" aria-labelledby="handling-skew"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> handling skew
  
  
</h4>
    
<p>Sometimes, there might be extremely large grouped objects (e.g., a social network where one user has millions of followers). These <em>hot keys</em> lead to skew, or imbalanced work loads (different than read/write skew race conditions). Apache Pig uses a <em>skewed join</em>, and Crunch uses <em>sharded join</em> to handle these workflows.</p>
<h3 class="no_toc" id="map-side-join">
  
  
    <a href="#map-side-join" class="anchor-heading" aria-labelledby="map-side-join"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Map-Side Join
  
  
</h3>
    
<p>Previous examples put join logic in reducer, but another method is to put join logic in mapper. Reduce-side has the advantage that you don’t need to make assumptions about input data, but downside is all the sorting, copying, and merging can be expensive.</p>

<p>If you can make assumptions about the input data, map-side are faster. They don’t have a reducer; they take one input and write one output onto the filesystem.</p>
<h4 class="no_toc" id="broadcast-hash-joins">
  
  
    <a href="#broadcast-hash-joins" class="anchor-heading" aria-labelledby="broadcast-hash-joins"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> broadcast hash joins
  
  
</h4>
    
<p>If you need to join a large dataset to a small dataset, you could load the entire small dataset into memory and use it as a hash map. Pig (replicated joins), Hive (MapJoin), Cascading, and Crunch all support this, as does Impala’s data warehouse.</p>
<h4 class="no_toc" id="partitioned-hash-joins">
  
  
    <a href="#partitioned-hash-joins" class="anchor-heading" aria-labelledby="partitioned-hash-joins"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> partitioned hash joins
  
  
</h4>
    
<p>If inputs to the map-side join are partitioned in the same way, then you can apply the hash join approach to each partition independently</p>
<h3 class="no_toc" id="the-output-of-batch-workflows">
  
  
    <a href="#the-output-of-batch-workflows" class="anchor-heading" aria-labelledby="the-output-of-batch-workflows"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> The Output of Batch Workflows
  
  
</h3>
    
<p>Google’s original use of MapReduce was to build indexes for its search engine. Even today, MapReduce is a good workflow for building search indexes for Lucene/Solr. Creating full-text indexes by scanning all documents is a good use case, and since indexes are read-only, the output is immutable.
The mappers partition the set of documents as needed, each reducer builds the index for its partition, and the index files are written to the distributed filesystem. It pararellises very well.</p>

<p>Machine learning systems such as clasifiers and recommendation systems are a common use for batch processing.</p>
<h4 class="no_toc" id="key-value-stores-as-batch-process-output">
  
  
    <a href="#key-value-stores-as-batch-process-output" class="anchor-heading" aria-labelledby="key-value-stores-as-batch-process-output"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> key-value stores as batch process output
  
  
</h4>
    
<p>The output of those batch jobs is often some kind of database.</p>

<p>So, how does the output from the batch process get back into a database?</p>

<p>Writing from the batch job directly to the database server is a bad idea:</p>
<ul>
  <li>Making a network request for every single record is magnitude slower than the normal throughput of a batch task.</li>
  <li>Mappers or reducers concurrently write to the same output database and it can be easily overwhelmed.</li>
  <li>You have to worry about the results from partially completed jobs being visible to other systems.</li>
</ul>

<p>A much better solution is to build a brand new database inside the batch job an write it as files to the job’s output directory, so it can be loaded in bulk into servers that handle read-only queries. Various key-value stores support building database files in MapReduce including Voldemort, Terrapin, ElephantDB and HBase bulk loading.</p>
<h4 class="no_toc" id="philosophy-of-batch-process-outputs">
  
  
    <a href="#philosophy-of-batch-process-outputs" class="anchor-heading" aria-labelledby="philosophy-of-batch-process-outputs"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> philosophy of batch process outputs
  
  
</h4>
    
<p>Batch processing adopts the Unix philosophy: input is left unchanged, any previous output is overwritten, there are no other side effects, and this makes them performant and easy to maintain.</p>
<ul>
  <li>if you introduce a software bug, you can roll back to a previous version easily</li>
  <li>feature development can proceed more quickly (<em>minimizing irreversibility</em>)</li>
  <li>automatic retries that will make batch processes more tolerant to transient issues</li>
  <li>same set of files can be used as inputs for various jobs</li>
  <li>separate the logic from the wiring</li>
</ul>
<h3 class="no_toc" id="comparing-hadoop-to-distributed-databases">
  
  
    <a href="#comparing-hadoop-to-distributed-databases" class="anchor-heading" aria-labelledby="comparing-hadoop-to-distributed-databases"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Comparing Hadoop to Distributed Databases
  
  
</h3>
    
<p>Ideas of MapReduce had already been seen in <em>massively parallel processing</em> databases (MPP) before, but instead of focusing on parallel execution of analytic queries on a cluster of machines, MapReduce allows for something much more like an OS that can execute arbitrary programs.</p>
<h4 class="no_toc" id="diversity-of-storage">
  
  
    <a href="#diversity-of-storage" class="anchor-heading" aria-labelledby="diversity-of-storage"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> diversity of storage
  
  
</h4>
    
<p>Databases require you to structure you according to a particular model, while files on a distributed filesystem are just a sequence of bytes. Often, data is just dumped to a distributed file system without knowing what might be done. Although we might think it desirable to carefully structure data to ensure data quality (as in databases), sometimes making the data available is the most useful (see data warehouses and joins across previously disparate pieces of data). The interpretation of the data becomes the consumers problem (schema on read). This approach is the called the <em>sushi principle</em> (raw is better).</p>
<h4 class="no_toc" id="diversity-of-processing-models">
  
  
    <a href="#diversity-of-processing-models" class="anchor-heading" aria-labelledby="diversity-of-processing-models"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> diversity of processing models
  
  
</h4>
    
<p>MPP databases, because their entire stack is integrated, can be optimized for their particular use case, and SQL queries as a widely used declarative language can be effectively leveraged by business analysts (and their data viz tools, like Tableau).</p>

<p>Not all processing can be sensibly expressed in SQL, however. MapReduce allows you to build a SQL engine on top of the data (e.g., Hive), but the functionality extends far beyond just that. MapReduce and SQL are just two processing models built on top of Hadoop, there can be many others. The Hadoop ecosystem includes random-access OLTP databases like HBase, MPP databases like Impala, and neither use MapReduce.</p>
<h4 class="no_toc" id="designing-for-frequent-faults">
  
  
    <a href="#designing-for-frequent-faults" class="anchor-heading" aria-labelledby="designing-for-frequent-faults"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> designing for frequent faults
  
  
</h4>
    
<p>If a node crashes while a query is executing, most MPP databases abort the entire query. MPP databases also prefer to keep as much data as possible in memory.</p>

<p>MapReduce can tolerate the failure of a map or reduce task without it affecting the job. It is also very eager to write data to disk, partly for fault tolerance, and partly because the dataset might not fit in memory anyway.</p>

<p>MapReduce is more appropriate for larger jobs.</p>

<p>At Google, a MapReduce task that runs for an hour has an approximately 5% risk of being terminated to make space for higher-priority process.This is why MapReduce is designed to tolerate frequent unexpected task termination.</p>
<h2 id="beyond-mapreduce">
  
  
    <a href="#beyond-mapreduce" class="anchor-heading" aria-labelledby="beyond-mapreduce"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Beyond MapReduce
  
  
</h2>
    
<h3 class="no_toc" id="materialization-of-intermediary-state">
  
  
    <a href="#materialization-of-intermediary-state" class="anchor-heading" aria-labelledby="materialization-of-intermediary-state"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Materialization of Intermediary State
  
  
</h3>
    
<p>If the output of one job is just the input to another job, this is needlessly persisting intermediary state, or <em>materialization</em> (to eagerly compute the results of some operation and write it out rather than computing it on demand when requested.)</p>

<p>Unix, by comparison, streams data from pipe to pipe instead of materializing intermediary state. Downsides of materializing state:</p>
<ul>
  <li>MapReduce jobs can only start when all tasks in preceding job have completed, which means you are subject to straggler tasks</li>
  <li>mappers are often redundant, just reading in the same file that was written by a reducer</li>
  <li>storing intermediary state on a distributed file system means it’ll be stored many times, which is often overkill</li>
</ul>
<h4 class="no_toc" id="dataflow-engines">
  
  
    <a href="#dataflow-engines" class="anchor-heading" aria-labelledby="dataflow-engines"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> dataflow engines
  
  
</h4>
    
<p>Execution engines Spark, Tez, and Flink try and fix these problems. You string together <em>operators</em>, or custom functions to perform operations that don’t have to be alternating map and reduce functions.</p>
<h4 class="no_toc" id="fault-tolerance">
  
  
    <a href="#fault-tolerance" class="anchor-heading" aria-labelledby="fault-tolerance"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> fault tolerance
  
  
</h4>
    
<p>Persisting intermediary state allows MapReduce to be tolerant to faults, allowing you to resume from particular failures. Other engines don’t persist state to HDFS so they need to implement different methods for ensuring durability. Spark uses the resilient distributed dataset (RDD) abstraction to track ancestry of data, while Flink checkpoints operator state.</p>

<p>It is important to have deterministic operators, or else recomputing would cause cascading faults down the stream of consumers.</p>
<h3 class="no_toc" id="graphs-and-iterative-processing">
  
  
    <a href="#graphs-and-iterative-processing" class="anchor-heading" aria-labelledby="graphs-and-iterative-processing"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Graphs and Iterative Processing
  
  
</h3>
    
<p>It’s interesting to look at graphs in batch processing context, where the goal is to perform some kind of offline processing or analysis on an entire graph. This need often arises in machine learning applications such as recommednation engines, or in ranking systems.</p>

<p>“repeating until done” cannot be expressed in plain MapReduce as it runs in a single pass over the data and some extra trickery is necessary.</p>

<p>An optimisation for batch processing graphs, the bulk synchronous parallel (BSP) has become popular. It is implemented by Apache Giraph, Spark’s GraphX API, and Flink’s Gelly API (<em>Pregel</em> model, as Google Pregel paper popularised it).</p>

<p>One vertex can “send a message” to another vertex, and typically those messages are sent along the edges in a graph.</p>

<p>The difference from MapReduce is that a vertex remembers its state in memory from one iteration to the next.</p>

<p>The fact that vertices can only communicate by message passing helps improve the performance of Pregel jobs, since messages can be batched.</p>

<p>Fault tolerance is achieved by periodically checkpointing the state of all vertices at the end of an interation.</p>

<p>The framework may partition the graph in arbitrary ways.</p>

<p>Graph algorithms often have a lot of cross-machine communication overhead, and the intermediate state is often bigger than the original graph.</p>

<p>If your graph can fit into memory on a single computer, it’s quite likely that a single-machine algorithm will outperform a distributed batch process. If the graph is too big to fit on a single machine, a distributed approach such as Pregel is unavoidable.</p>
<h2 id="chapter-summary-9">
  
  
    <a href="#chapter-summary-9" class="anchor-heading" aria-labelledby="chapter-summary-9"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Chapter Summary
  
  
</h2>
    
<p>Design philosophy of Unix (inputs are immutable, outputs are intended to become the input to another (as yet unknown) program, and complex problems are solved by composing small tools that “do one thing well”) informs MapReduce and more recent dataflow engines.</p>

<p>Uniform interface in Unix is files and pipes, and in MapReduce, it is the distributed file system.</p>

<p>There are two problems distributed batch processing needs to solve:</p>
<ul>
  <li>
<strong>partitioning</strong> - mappers are partitioned according to input file blocks, and output is repartitioned, sorted, and merged into configurable amount of reducer partitions.</li>
  <li>
<strong>fault tolerance</strong> - MapReduce frequently writes to disk, which makes it easier to resume failed tasks, but later dataflow engines perform less materialization of intermediate state and keep more in memory.</li>
</ul>

<p>Examples of join algorithms for MapReduce:</p>
<ul>
  <li>
<strong>sort-merge joins</strong> - each of the inputs being joined foes through a mapper that extracts join key. by partitioning, sorting, and merging, all records with the same key end up going to the same call of the reducer. the function can then output the joined records.</li>
  <li>
<strong>broadcast hash joins</strong> - one of the two join inputs is small, so it is not partitioned and it can be entirely loaded into a hash table. Thus, you can start a mapper for each partition of the large join input, load the hash table for the small input into each mapper, and then scan over the large input one record at a time, querying the hash table for each record.</li>
  <li>
<strong>partitioned hash joins</strong> - if the two join inputs are partitioned in the same way (using the same key, same hash function, same number of partitions), then the hash table approach can be used independently for each partition.</li>
</ul>

<p>Distributed batch processing engines have restricted programming model: callback functions are stateless and have no externally visible side effects, which allows the framework to hide difficult problems of distributed systems behind the abstraction; tasks can be retried safely, output of failed tasks can be discarded.</p>

<p>Code doesn’t need to worry about implementing fault-tolerance mechanisms, and these semantics are much stronger than in online services.</p>

<p>The distinguishing feature of batch processing is that it reads some input data and produces output data without modifying the input data. The output is <em>derived</em> from input. Also, the input data is <em>bounded</em>; it has a known, fixed size, and the job knows when it is done. This is contrasted to stream processing, which is <em>unbounded</em>.</p>
<h1 id="chapter-11-stream-processing">
  
  
    <a href="#chapter-11-stream-processing" class="anchor-heading" aria-labelledby="chapter-11-stream-processing"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Chapter 11: Stream Processing
  
  
</h1>
    
<p>A “stream” typically means data that is made avaialable incrementally over time: <code class="language-plaintext highlighter-rouge">stdin</code> and <code class="language-plaintext highlighter-rouge">stdout</code> in Unix, lazy lists, filesystem APIs (like Java’s <code class="language-plaintext highlighter-rouge">FileInputStream</code>), TCP connections, etc.</p>

<p><em>event streams</em> are mechanisms of data management, the unbounded, incrementally processed counterpart to batch data.</p>
<h2 id="transmitting-event-streams">
  
  
    <a href="#transmitting-event-streams" class="anchor-heading" aria-labelledby="transmitting-event-streams"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Transmitting Event Streams
  
  
</h2>
    
<p>Instead of files for batch processing, event streams process <em>events</em>, or small, self-contained, immutable objects (might be text, or JSON, or a binary string) containing details of something that happened at some point in time, typically packaged with some sort of timestamp, e.g., an action a user took.</p>

<p>An event is generated once by a <em>producer</em> (aka <em>publisher</em> or <em>sender</em>), and processed by multiple <em>consumers</em> (aka <em>subscribers</em> or <em>recipients</em>), and related records are grouped together in a <em>stream</em> or <em>topic</em>.</p>

<p>Instead of polling the consumers for new events (which gets expensive), consumers are notified when new events occur.</p>
<h3 class="no_toc" id="messaging-systems">
  
  
    <a href="#messaging-systems" class="anchor-heading" aria-labelledby="messaging-systems"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Messaging Systems
  
  
</h3>
    
<p>A <em>messaging system</em> might be used; producers send messages to this service and then consumers are notified. This is referred to as a <em>publish/subscribe</em> model.</p>

<ol>
  <li>what happens if the producers send messages faster than the producers can process them?
    <ol>
      <li>the system can drop messages</li>
      <li>the system can buffer messages in a queue – what happens as the queue grows is up to the system (written to disk, crash, etc.)</li>
      <li>the system can apply <em>backpressure</em> (<em>flow control</em>), blocking the producer from sending more messages</li>
    </ol>
  </li>
  <li>what happens if nodes crash or temporarily go offline?
    <ol>
      <li>durability might be required (replication to disk), but if you can afford to lose messages you might have higher throughput and lower latency</li>
    </ol>
  </li>
</ol>
<h4 class="no_toc" id="direct-messaging-from-producers-to-consumers">
  
  
    <a href="#direct-messaging-from-producers-to-consumers" class="anchor-heading" aria-labelledby="direct-messaging-from-producers-to-consumers"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> direct messaging from producers to consumers
  
  
</h4>
    
<p>Some data systems don’t use a message system:</p>
<ul>
  <li>UDP multicast for low latency applications (financial data)</li>
  <li>Brokerless messaging libraries like ZeroMQ and nanomsg, over TCP or IP multicast</li>
  <li>StatsD and Brubeck use UDP</li>
  <li>webhooks (consumer exposes a service over the network and producers make a direct HTTP or RPC request upon an event)</li>
</ul>
<h4 class="no_toc" id="message-broker">
  
  
    <a href="#message-broker" class="anchor-heading" aria-labelledby="message-broker"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> message broker
  
  
</h4>
    
<p>You can also send messages through a message broker, which acts like a database optimized for handling message streams. Consumers are asynchronous; a producer sends a message and the message broker only returns a message when the message is queued, not consumed.</p>

<p>Message brokers are like databases, and can even implement 2PC through XA or JTA, but they are different from databases:</p>
<ul>
  <li>databases keep data until it is explicitly deleted whereas message brokers typically delete messages after successful delivery</li>
  <li>message brokers assume their workload is fairly small, but if a substantial number of messages need to buffer, each individual message takes longer to process and the throughput may degrade</li>
  <li>databases offer secondary indexes while message brokers allow consumers to subscribe to a subset of messages based on a pattern</li>
  <li>databases support arbitrary queries but message brokers do not</li>
</ul>
<h4 class="no_toc" id="multiple-consumers">
  
  
    <a href="#multiple-consumers" class="anchor-heading" aria-labelledby="multiple-consumers"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> multiple consumers
  
  
</h4>
    
<p>When multiple consumers read messages, there are two main patterns:</p>
<ul>
  <li>
<strong>load balancing</strong> - each message is delivered to one consumer to process</li>
  <li>
<strong>fan-out</strong> - each message is delivered to all consumers</li>
</ul>
<h4 class="no_toc" id="acknowledgments-and-redelivery">
  
  
    <a href="#acknowledgments-and-redelivery" class="anchor-heading" aria-labelledby="acknowledgments-and-redelivery"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> acknowledgments and redelivery
  
  
</h4>
    
<p>Consumers may crash at any time, so message brokers use <em>acknowledgments</em> where a client must explicitly tell the broker when it has finished processing a message and the broker will remove it from the queue. When combined with load balancing, this redelivery feature might not preserve the ordering of messages.</p>
<h3 class="no_toc" id="partitioned-logs">
  
  
    <a href="#partitioned-logs" class="anchor-heading" aria-labelledby="partitioned-logs"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Partitioned Logs
  
  
</h3>
    
<p>With databases and filesystems, everything that is written to the database or the file is expected to be permenantly recorded, but with messages and message brokers, the act of receiving a message is destructive if the acknowledgment causes the message to be deleted from the queue. <em>Log-based message brokers</em> are a hybrid between the two paradigms.</p>

<p>A log is an append-only sequence of records on disk, so a message broker can be implemented where a producer appends records to a log, and a consumer reads from that log. To achieve higher throughput than a single disk can offer, the log can be partitioned, and within each partition, the broker assigns a monotonically increasing sequence number (<em>offset</em>), so messages within the partition are totally ordered, but not so across partitions.</p>

<p>Apache Kafka, Amazon Kinesis Streams, and Twitter’s DistributedLog are log-based message brokers. This is contrasted to the JMS/AMQP style message broker system (e.g., RabbitMQ).</p>

<p>The log-based approach trivially supports fan-out, since any consumer could subscribe to the log, but load balancing is a little different (typically attained by assigning a partition to a particular consumer). This has the downsides that the number of nodes consuming a topic can be at most the number of log partitions, and if a single message is slow all other messages are blocked (<em>head of line blocking</em>).</p>

<p>The offset makes it easy to tell which records have been processed, and this offset works very similarly to the <em>log sequence number</em> from single-leader replication (if a follower becomes disconected, the log sequence number tells it where to begin catching up when it reconnects). The message broker behaves like a leader database, and the consumer a follower.</p>
<h4 class="no_toc" id="buffer-disk-usage">
  
  
    <a href="#buffer-disk-usage" class="anchor-heading" aria-labelledby="buffer-disk-usage"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> buffer disk usage
  
  
</h4>
    
<p>Eventually, the log will run out of disk space, so older logs segments need to be removed by implementing a bounded-size buffer that discards old messages when it gets full (<em>circular buffer</em> or <em>ring buffer</em>). E.g., the average hdd is 6 TB, and the average write is 150 MB/s, which means it would take ~11 hours to fill the disk.</p>

<p>If a consumer falls so far behind that the messages are no longer on disk, those messages will be lost, but you can monitor a consumer and raise an alert if they fall too far behind. You can also add consumers for different purposes without worrying about affecting throughput, as consumers are only reading from the log.</p>
<h2 id="databases-and-streams">
  
  
    <a href="#databases-and-streams" class="anchor-heading" aria-labelledby="databases-and-streams"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Databases and Streams
  
  
</h2>
    
<p>An event is a record of a thing happening, and that thing might be a <em>write to a database</em>, meaning that streams and databases are fundamentally similar. For example, a replication log is a stream of database write events. The followers follow that stream to ensure their copy is up to date with the producer.</p>
<h3 class="no_toc" id="keeping-systems-in-sync">
  
  
    <a href="#keeping-systems-in-sync" class="anchor-heading" aria-labelledby="keeping-systems-in-sync"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Keeping Systems in Sync
  
  
</h3>
    
<p>There is no single system that can satisfy all data storage, querying, and processing needs, but the sprawl of services need to be kept in sync. Sometimes, batch processes are used to keep different systems in sync (data warehouses). Another method is to use <em>dual writes</em> where application code explicitly writes to each data system when data changes. With dual writes there are race conditions that might happen to cause systems to be permenantly out of sync with each other, and you need concurrency mechanisms to detect what would otherwise be a silent failure.</p>

<p>In a single-leader system, the state machine replication approach (if every follower processes events in the same order as the leader, than every replica will end up in the same final state) works, but with disparate systems there might be many leader-followers. Ideally we’d be able to make the database the leader, then everything else the follower (search index, cache, etc.)</p>
<h3 class="no_toc" id="change-data-capture">
  
  
    <a href="#change-data-capture" class="anchor-heading" aria-labelledby="change-data-capture"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Change Data Capture
  
  
</h3>
    
<p><em>change data capture</em> (CDC) is the process of observing all data changes written to the system of record database and extracting them in a form that can be replicated to other derived data systems. All changes made to the system of record database are reflected in the derived data systems.</p>

<p>You could implement CDC with database triggers, but these are slow and brittle. LinkedIn’s Database, Facebook’s Wormhole, and Yahoo’s Sherpa use this idea at a large scale. Bottled Water implements CDC for PostgreSQL using an API that decodes the write-ahead log, Maxwell and Debezium do something similar for MySQL with the binlog, Mongoriver reads the MongoDB oplog, and GoldenGate provides similar facilities for Oracle.</p>

<p>If you have a log of all changes you could recreate the entire database, but this might take too long and take up too much space, so its best to work off a snapshot. Every time you add a new derived data system you’d need to go through the snapshot process, but <em>log compaction</em> helps. If you store every update with a primary key, and the most recent update replaces the previous, you can scan the entire log and just pull out most recent values for a key. Log compaction is supported by Apache Kafka.</p>

<p>Databases are beginning to support CDC as a first-class interface. RethinkDB allows queries to subscribe to notifications when the results of a query change. Firebase and CouchDB provide synchronization, and VoltDB allows transactions to continuously export data from a database as a stream. Kafka Connect tries to integrate CDC tools for many database systems.</p>
<h3 class="no_toc" id="event-sourcing">
  
  
    <a href="#event-sourcing" class="anchor-heading" aria-labelledby="event-sourcing"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Event Sourcing
  
  
</h3>
    
<p>CDC is similar to domain-driven design’s (DDD) idea of event sourcing. CDC uses the database in a mutable way, updating and deleting records as needed, but event sourcing, the application logic is built on the basis of immutable events that are written to an event log, and updates and deletes are discouraged.</p>

<p>Event sourcing is powerful for data modelling: user’s actions are immutable events, instead of recording the effect of those actions on a mutable database. This makes updating applications easier and helps debugging, as well as limits application bugs.</p>

<p>For example, the event “student canceled their course enrolment” clearly expresses intent of a single action in a neutral way, while side effects “one entry was deleted from the enrolments table, one cancellation was added to the student feedback table” embed a lot of assumptions about how the data is going to be used. If a new event is added, say, “next person in queue is added to class”, event sourcing makes it easier to chain the behavior to the current event.</p>

<p>Since events are typically modelled at a higher level, later events typically don’t overwrite previous events, so log compaction is not possible in the same way.</p>
<h4 class="no_toc" id="commands-and-events">
  
  
    <a href="#commands-and-events" class="anchor-heading" aria-labelledby="commands-and-events"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> commands and events
  
  
</h4>
    
<p>When a request from a user first arrives, it is a <em>command</em>, and when it is successful it becomes an <em>event</em>. When an <em>event</em> is generated, it becomes a <em>fact</em>.</p>
<h3 class="no_toc" id="state-streams-and-immutability">
  
  
    <a href="#state-streams-and-immutability" class="anchor-heading" aria-labelledby="state-streams-and-immutability"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> State, Streams, and Immutability
  
  
</h3>
    
<p>The <em>changelog</em> represents the evolution of state over time. If you consider the log of events to be the system of record, and any mutable state as being derived from it, it becomes easier to reason about the flow of data through a system.</p>

<p>Immutability in databases can be seen in accounting in an append-only <em>ledger</em> – if there is a mistake, data isn’t erased, but a compensating action (e.g., a refund) is added. This is important for auditability.</p>

<p>If you separate mutable state from immutable events, you can derive several different read-oriented representations of the same log of events.</p>

<p><em>command query responsibility segregation</em> (CQRS) - separating the form in which the data is written from the form in which the data is read. There is a fallacy that data must be written in the same form in which it is read, e.g., it is entirely reasonable to denormalize data that is being read.</p>

<p>The biggest downside to event sourcing and change data capture is that consumers of the event log are asynchronous, so reads after write consistency might not be guaranteed. You might need to implement synchronous, atomic commits to read consumers. On the flipside, concurrency control is simplified by a single event log, as multi-object writes become less prevalent. If the event log and the application state are partitioned the same way, you don’t need concurrency control, as there is just a single threaded log consumer.</p>

<p>Use cases for immutable data depend on the data set. If you have data that mostly grows, then it is easier to be immutable, but if your dataset is frequently updates and deletes, the immutable event log would grow prohibitively large.</p>

<p>Sometimes you might need to permenantly delete data, not just tombstone it. Dataomic calls this <em>excision</em>, and the VCS Fossil calls this <em>shunning</em>. Deleting data is very hard.</p>
<h2 id="processing-streams">
  
  
    <a href="#processing-streams" class="anchor-heading" aria-labelledby="processing-streams"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Processing Streams
  
  
</h2>
    
<p>What can you do once you’ve set up a stream?</p>
<ol>
  <li>take the data in the events and write it to a database, cache, search index, etc, from where it can be queried by other clients</li>
  <li>you can push the events to users, like email or push notifications</li>
  <li>you can process input streams to produce output streams</li>
</ol>

<p>A piece of code that processes streams is an <em>operator</em> or a <em>job</em>. Because streams are unbounded and never end, sorting doesn’t make sense, and fault-tolerance mechanisms need to change as jobs can’t be cleanly retried.</p>
<h3 class="no_toc" id="uses-of-stream-processing">
  
  
    <a href="#uses-of-stream-processing" class="anchor-heading" aria-labelledby="uses-of-stream-processing"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Uses of Stream Processing
  
  
</h3>
    
<p><strong>complex event processing</strong> (CEP) is an approach for analyzing event streams, and is geared for pattern matching, allowing you to specify rules to search for certain patterns of events in a stream. CEP systems use a high-level declarative language (like SQL or a GUI) to describe a pattern of events, and when it is detected, a <em>complex event</em> is created with details of the event. Reverses the standard data model - queries are long lived and data is transient.</p>

<p><strong>stream analytics</strong> slightly different from CEP and geared towards aggregations and statistical metrics over a large number of events, e.g., measuring the rate of some type of event, or calculating the rolling average over some time period. These often use probablistic algorithms such as Bloom filters for set membership, HyperLogLog for cardinality estimation, and various percentile estimation algos. Many stream processing framworks are designed with analytics in mind: Apache Storm, Spark Streaming, Flink, Concord, Samza, and Kafka Streams.</p>

<p><strong>materialized views</strong> caches, search indexes, and data warehouses can be thought of as materialized views on the original log</p>

<p><strong>search on streams</strong> - you can create a query and run a stream through this query (similar to CEP). You can get speed increases by indexing the query as well.</p>
<h3 class="no_toc" id="reasoning-about-time">
  
  
    <a href="#reasoning-about-time" class="anchor-heading" aria-labelledby="reasoning-about-time"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Reasoning About Time
  
  
</h3>
    
<p>In a batch process, the time at which the process is run has nothing to do with the time at which the events actually occurred.</p>

<p>Many stream processing frameworks use the local system clock on the processing machine (processing time) to determine windowing. It is a simple approach that breaks down if there is any significant processing lag.</p>

<p>Confusing event time and processing time leads to bad data. Processing time may be unreliable as the stream processor may queue events, restart, etc. It’s better to take into account the original event time to count rates. You can never be sure when you have received all the events.</p>

<p>You can time out and declare a window ready after you have not seen any new events for a while, but it could still happen that some events are delayed due a network interruption. You need to be able to handle such stranggler events that arrive after the window has already been declared complete.</p>

<p>You can ignore the stranggler events, tracking the number of dropped events as a metric. Publish a correction, an updated value for the window with stranglers included. You may also need to retrat the previous output.</p>

<p>To adjust for incofrrect device clocks, one approach is to log three timestamps:</p>
<ul>
  <li>The time at which the event occurred, according to the device clock</li>
  <li>The time at which the event was sent to the server, according to the device clock</li>
  <li>The time at which the event was received by the server, according to the server clock.</li>
  <li>You can estimate the offset between the device clock and the server clock, then apply that offset to the event timestamp, and thus estimate the true time at which the event actually ocurred.</li>
</ul>

<p>Several types of windows are in common use:</p>
<ul>
  <li>
<strong>Tumbling window</strong>: Fixed length. If you have a 1-minute tumbling window, all events between 10:03:00 and 10:03:59 will be grouped in one window, next window would be 10:04:00-10:04:59</li>
  <li>
<strong>Hopping window</strong>: Fixed length, but allows windows to overlap in order to provide some smoothing. If you have a 5-minute window with a hop size of 1 minute, it would contain the events between 10:03:00 and 10:07:59, next window would cover 10:04:00-10:08:59</li>
  <li>
<strong>Sliding window</strong>: Events that occur within some interval of each other. For example, a 5-minute sliding window would cover 10:03:39 and 10:08:12 because they are less than 4 minutes apart.</li>
  <li>
<strong>Session window</strong>: No fixed duration. All events for the same user, the window ends when the user has been inactive for some time (30 minutes). Common in website analytics</li>
</ul>
<h3 class="no_toc" id="stream-joins">
  
  
    <a href="#stream-joins" class="anchor-heading" aria-labelledby="stream-joins"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Stream Joins
  
  
</h3>
    
<p>Same use cases for joining data in streams as there is in batch processing, but the fact that streams are unbounded makes joins more difficult.</p>

<ul>
  <li>
<strong>stream-stream join (<em>window join</em>)</strong>: say you need to bring together clickstream data (e.g., search and click action). a stream processor needs to maintain state, e.g., all click data for the last hour, and if there is a matching click event after a search or not.</li>
  <li>
<strong>stream-table join (<em>stream enrichment</em>)</strong>: if we need to add in additional data otherwise missing from an event stream. similar to a hash join, where a local copy of a database is kept in memory. since streams are long-lived, you could use change data capture to keep that in memory or on disk index up to date with updates to the source of record data.</li>
  <li>
<strong>table-table join (<em>materialized view maintenance</em>)</strong>: stream needs to maintain a join of two disparate tables for the stream to access</li>
</ul>
<h4 class="no_toc" id="time-dependence-of-joins">
  
  
    <a href="#time-dependence-of-joins" class="anchor-heading" aria-labelledby="time-dependence-of-joins"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> time dependence of joins
  
  
</h4>
    
<p>If state changes over time, and you join with some state, what point in time do you use for the join? If the ordering of events is undetermined, the join becomes non-deterministic, which in data warehousing is called <em>slowly changing dimension</em> (SDC) and might be addressed by using a unique identifier for a particular version of the joined data.</p>
<h3 class="no_toc" id="fault-tolerance-1">
  
  
    <a href="#fault-tolerance-1" class="anchor-heading" aria-labelledby="fault-tolerance-1"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Fault Tolerance
  
  
</h3>
    
<p>Batch processes can be retried, but what about streams? <em>exactly once</em> semantics mean that a record appears to be processed effectively once.</p>
<h4 class="no_toc" id="microbatching-and-checkpointing">
  
  
    <a href="#microbatching-and-checkpointing" class="anchor-heading" aria-labelledby="microbatching-and-checkpointing"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> microbatching and checkpointing
  
  
</h4>
    
<p><strong>microbatching</strong> - breaking the stream into small blocks and treating each block like a mini batch. There is scheduling and coordination overhead.
<strong>checkpointing</strong> - used be Apache Flink, generates rolling checkpoints and stores them to durable storage</p>

<p>In order to give the appearance of exactly-once processing, need to ensure that all outputs and side effects of processing an event take place only if processing is successful.</p>
<h4 class="no_toc" id="idempotence">
  
  
    <a href="#idempotence" class="anchor-heading" aria-labelledby="idempotence"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> idempotence
  
  
</h4>
    
<p>you might also rely on idempotence, or, if you perform an operation multiple times, it has the same effect as if you performed it only once. even if an operation isn’t idempotent by default, you can likely make it so by keeping metadata.</p>
<h2 id="chapter-summary-10">
  
  
    <a href="#chapter-summary-10" class="anchor-heading" aria-labelledby="chapter-summary-10"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Chapter Summary
  
  
</h2>
    
<p>Streaming is very similar to batch processing, but done continuously on unbounded streams rather than fixed-size input. Message brokers and event logs serve as the streaming equivalent of a filesystem.</p>

<p>Two types of message brokers:</p>
<ol>
  <li>
<strong>AMQP/JMS-style message broker</strong> - broker assigns individual messages to consumers, consumers acknowledge messages, then messages are deleted from the broker. this style is useful when exact order of messages doesn’t matter, and you don’t need to return to anything that was already read in the past</li>
  <li>
<strong>log-based message broker</strong> - broker assigns all messages in a partition to the same consumer node, always delivers messages in the same order. parallelism is achieved through partitioning, and consumers track progress by checkpointing the offest of the last message they have processed. broker retains messages on disk, so you can jump back to old messages.</li>
</ol>

<p>log-based approach is similar to replication logs for database storage.</p>

<p>streams might come from user activity, events, sensors providing periodic readings, and data feeds – we can also think of writes to a database like a stream, and log compaction allows the database to keep a full copy of the contents of a database.</p>

<p>When we represent databases as streams, we can start to integrate data systems: caches, search indexes, and analytics systems are derived data systems from the system of record, the database.</p>

<p>There are several purposes of stream processing:</p>
<ul>
  <li>
<strong>complex event processing</strong> - searching for event patterns</li>
  <li>
<strong>stream analytics</strong> - computing windowed aggregation</li>
  <li>
<strong>materialized views</strong> - keeping derived data systems up to date</li>
</ul>

<p>Time is difficult to reason about in streams because of a difference in processing time and event timestamps, and the problem of dealing with straggler events that arrive after you thought your window was complete.</p>

<p>There are at least 3 types of joins that may appear in stream processes:</p>
<ol>
  <li><strong>stream-stream joins</strong></li>
  <li><strong>stream-table joins</strong></li>
  <li><strong>table-table joins</strong></li>
</ol>
<h1 id="chapter-12-the-future-of-data-systems">
  
  
    <a href="#chapter-12-the-future-of-data-systems" class="anchor-heading" aria-labelledby="chapter-12-the-future-of-data-systems"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Chapter 12: The Future of Data Systems
  
  
</h1>
    
<h2 id="data-integration">
  
  
    <a href="#data-integration" class="anchor-heading" aria-labelledby="data-integration"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Data Integration
  
  
</h2>
    
<p>For every problem, there might be several solutions. Even if you understand usage patterns, data is used in different ways, and you end up having to cobble together several different pieces of software.</p>
<h3 class="no_toc" id="combining-specialized-tools-by-deriving-data">
  
  
    <a href="#combining-specialized-tools-by-deriving-data" class="anchor-heading" aria-labelledby="combining-specialized-tools-by-deriving-data"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Combining Specialized Tools by Deriving Data
  
  
</h3>
    
<h4 class="no_toc" id="reasoning-about-dataflows">
  
  
    <a href="#reasoning-about-dataflows" class="anchor-heading" aria-labelledby="reasoning-about-dataflows"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> reasoning about dataflows
  
  
</h4>
    
<p>When copies of the same data need to be stored in several storage systems, you need to be very clear about inputs and outputs. Where is data written first, what is derived from what?</p>

<p>Imagine a system that uses writes to a database to then use change data capture to create an index. If the index is derived solely from database writes, you can be sure the index is derived solely from system of record, as writing to the database is the only way to supply new inputs. But if you can update the database also through the index, you have problems of concurrent writes, and no system of record. Funnelling all inputs through a single system is an application of state machine replication.</p>
<h4 class="no_toc" id="derived-data-vs-distributed-transactions">
  
  
    <a href="#derived-data-vs-distributed-transactions" class="anchor-heading" aria-labelledby="derived-data-vs-distributed-transactions"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> derived data vs distributed transactions
  
  
</h4>
    
<p>Distributed transactions decide on an ordering of writes by using locks for mutual exclusion, while CDC and event sourcing (derived data) use a log for ordering. Distributed transactions use atomic commit to ensure exactly once semantics, while log-based systems are based on deterministic retry and idempotence.</p>

<p>Biggest difference between the two approaches are that transaction systems provide linearizability which provide useful consistency guarantees if needed (read your own writes).</p>

<p>In the absence of widespread support for a good distributed transaction protocol (XA has poor fault tolerance and performance characteristics), log-based derived data is the most promising approach for integrating different data systems.</p>
<h4 class="no_toc" id="limits-of-total-ordering">
  
  
    <a href="#limits-of-total-ordering" class="anchor-heading" aria-labelledby="limits-of-total-ordering"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> limits of total ordering
  
  
</h4>
    
<p>However, as systems are scaled towards bigger and more coplex worloads, limitiations emerge:</p>
<ul>
  <li>Constructing a totally ordered log requires all events to pass through a single leader node that decides on the ordering, and you need to partition if the load is too large, making ordering ambiguous</li>
  <li>An undefined ordering of events that originate on multiple datacenters.</li>
  <li>When two events originate in different services, there is no defined order for those events.</li>
  <li>Some applications maintain client-side state. Clients and servers are very likely to see events in different orders.</li>
</ul>

<p>Deciding on a total order of events is known as <em>total order broadcast</em>, which is equivalent to consensus. It is still an open research problem to design consensus algorithms that can scale beyond the throughput of a single node.</p>
<h4 class="no_toc" id="ordering-events-to-capture-causality">
  
  
    <a href="#ordering-events-to-capture-causality" class="anchor-heading" aria-labelledby="ordering-events-to-capture-causality"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> ordering events to capture causality
  
  
</h4>
    
<p>If there is no causal link between events, no need for total order since writes can happen concurrently, or objects can be updated per key on a partition.</p>
<h3 class="no_toc" id="batch-and-stream-processing">
  
  
    <a href="#batch-and-stream-processing" class="anchor-heading" aria-labelledby="batch-and-stream-processing"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Batch and Stream Processing
  
  
</h3>
    
<p>The goal of data integration is that data ends up in the right form in the right places. The outputs of batch and stream processes are derived datasets, e.g., search indexes, materialized views, recommendations to show users, aggregate metrics, etc.</p>

<p>Main difference is that stream processing operates on unbounded datasets.</p>

<p>Batch processing has functional flavor: deterministic, pure functions whose output depends only on the input and no side effects other than explicit outputs, inputs as immutable and outputs as append-only. Stream processing extends operators to allow managed, fault-tolerant state.</p>
<h4 class="no_toc" id="reprocessing-data-for-application-evolution">
  
  
    <a href="#reprocessing-data-for-application-evolution" class="anchor-heading" aria-labelledby="reprocessing-data-for-application-evolution"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> reprocessing data for application evolution
  
  
</h4>
    
<p>Reprocessing allows for the evolution of applications, as it is possible to restructure a dataset based on a completely different model. Derived views allow gradual evolution, and gradual migration allows every stage to be easily reversible.</p>
<h4 class="no_toc" id="lambda-architecture">
  
  
    <a href="#lambda-architecture" class="anchor-heading" aria-labelledby="lambda-architecture"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> lambda architecture
  
  
</h4>
    
<p>Combines batch and stream processing. The core idea is that incoming data should be recorded by appending immutable events to an always-growing dataset, and from these events, read-optimized views are derived, or running two systems in parallel.</p>

<p>The stream processor consumes the events and produces a quick approximate update to the view, then the batch processor later consumes the <em>same</em> events and produces the corrected version of the derived view.</p>

<p>The downsides:</p>
<ul>
  <li>maintaining both batch and stream logic is significant extra effort</li>
  <li>since stream and batch produce separate outputs, they need to be merged to respond to user requests</li>
  <li>reprocessing the entire dataset is expensive, so the batch processor runs on incremental updates, which might run into time problems (straggler events, etc)</li>
</ul>
<h2 id="unbundling-databases">
  
  
    <a href="#unbundling-databases" class="anchor-heading" aria-labelledby="unbundling-databases"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Unbundling Databases
  
  
</h2>
    
<p>Batch and stream processors are like elaborate implementations of triggers, stored procedures, and materialised view maintenance routines. The derived data systems they maintain are like different index types.</p>

<p>There are two avenues by which different storage and processing tools can nevertheless be composed into a cohesive system:</p>
<ul>
  <li>
<strong>Federated databases</strong> <em>unifying reads</em>: unifying reads. It is possible to provide a unified query interface to a wide variety of underlying storate engines and processing methods, this is known as federated database or polystore. An example is PostgreSQL’s foreign data wrapper.</li>
  <li>
<strong>Unbundled databases</strong> <em>unifying writes</em>: unifying writes. When we compose several storage systems, we need to ensure that all data changes end up in all the right places, even in the face of faults, it is like unbundling a database’s index-maintenance features in a way that can synchronise writes across disparate technologies.</li>
</ul>

<p>unifying writes to several storage systems in sync is the harder engineering problem.</p>

<p>Synchronising writes requires distributed transactions across heterogeneous storage systems which may be the wrong solution. An asynchronous event log with idempotent writes is a much more robust and practical approach.</p>

<p>The big advantage is <em>loose coupling</em> between various components:</p>

<ul>
  <li>Asynchronous event streams make the system as a whole more robust to outages or performance degradation of individual components.</li>
  <li>Unbundling data systems allows different software components and services to be developed, improved and maintained independently from each other by different teams.</li>
</ul>

<p>If there is a single technology that does everything you need, you’re most likely best off simply using that product rather than trying to reimplement it yourself from lower-level components. The advantages of unbundling and composition only come into the picture when there is no single piece of software that satisfies all your requirements.</p>
<h4 class="no_toc" id="separation-of-application-code-and-state">
  
  
    <a href="#separation-of-application-code-and-state" class="anchor-heading" aria-labelledby="separation-of-application-code-and-state"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> separation of application code and state
  
  
</h4>
    
<p>It makes sense to have some parts of a system that specialize in durable data storage, and other parts that specialize in running application code. The two can interact while still remaining independent.</p>

<p>The trend has been to keep stateless application logic separate from state management (databases): not putting application logic in the database and not putting persistent state in the application.</p>

<p>Dataflow, interplay between state changes and application code
Instead of treating the database as a passive variable that is manipulated by the application, application code responds to state changes in one place by triggering state changes in another place.</p>
<h4 class="no_toc" id="stream-processors-and-services">
  
  
    <a href="#stream-processors-and-services" class="anchor-heading" aria-labelledby="stream-processors-and-services"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> stream processors and services
  
  
</h4>
    
<p>A customer is purchasing an item that is priced in one currency but paid in another currency. In order to perform the currency conversion, you need to know the current exchange rate.</p>

<p>This could be implemented in two ways:</p>
<ul>
  <li>
<strong>Microservices approach</strong>, the code that processes the purchase would probably wuery an exchange-rate service or a database in order to obtain the current rate for a particular currency.</li>
  <li>
<strong>Dataflow approach</strong>, the code that processes purchases would subscribe to a stream of exchange rate updates ahead of time, and record the current rate in a local database whenever it changes. When it comes to processing the purchase, it only needs to query the local database.</li>
</ul>

<p>The dataflow is not only faster, but it is also more robust to the failure of another service.</p>
<h3 class="no_toc" id="observing-derived-state">
  
  
    <a href="#observing-derived-state" class="anchor-heading" aria-labelledby="observing-derived-state"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Observing Derived State
  
  
</h3>
    
<p>Break the data flow into two paths: <em>write path</em> and the <em>read path</em>. Write path is eagerly evaluated (as it comes in), and read path is lazily evaluated (as it is needed).</p>
<h4 class="no_toc" id="materialized-views-and-caching">
  
  
    <a href="#materialized-views-and-caching" class="anchor-heading" aria-labelledby="materialized-views-and-caching"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> materialized views and caching
  
  
</h4>
    
<p>A full-text search index is a good example: the write path updates the index, and the read path searches the index for keywords.</p>

<p>If you don’t have an index, a search query would have to scan over all documents, which is very expensive. No index means less work on the write path (no index to update), but a lot more work on the read path.</p>

<p>Another option would be to precompute the search results for only a fixed set of the most common queries. The uncommon queries can still be served from the inxed. This is what we call a cache although it could also be called a materialised view.</p>
<h4 class="no_toc" id="read-are-events-too">
  
  
    <a href="#read-are-events-too" class="anchor-heading" aria-labelledby="read-are-events-too"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> read are events too
  
  
</h4>
    
<p>It is also possible to represent read requests as streams of events, and send both the read events and write events through a stream processor; the processor responds to read events by emiting the result of the read to an output stream.</p>

<p>It would allow you to reconstruct what the user saw before they made a particular decision.</p>

<p>Enables better tracking of casual dependencies.</p>
<h2 id="aiming-for-correctness">
  
  
    <a href="#aiming-for-correctness" class="anchor-heading" aria-labelledby="aiming-for-correctness"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Aiming for Correctness
  
  
</h2>
    
<p>If your application can tolerate occasionally corrupting or losing data in unpredictable ways, life is a lot simpler. If you need stronger assurances of correctness, the serializability and atomic commit are established approaches.</p>

<p>While traditional transaction approach is not going away, there are some ways of thinking about correctness in the context of dataflow architectures.</p>
<h4 class="no_toc" id="the-end-to-end-argument-for-databases">
  
  
    <a href="#the-end-to-end-argument-for-databases" class="anchor-heading" aria-labelledby="the-end-to-end-argument-for-databases"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> the end-to-end argument for databases
  
  
</h4>
    
<p>Bugs occur, and people make mistakes. Favor immutable and append-only data, because it is easier to recover from such mistakes.</p>

<p>We’ve seen the idea of <em>exactly-once</em> (or <em>effectively-once</em>) semantics. If something goes wrong while processing a message, you can either give up or try again. If you try again, there is the risk that it actually succeeded the first time, the message ends up being processed twice.</p>

<p>Exactly-once means arranging the computation such that the final effect is the same as if no faults had occurred.</p>

<p>One of the most effective approaches is to make the operation idempotent, to ensure that it has the same effect, no matter whether it is executed once or multiple times. Idempotence requires some effort and care: you may need to maintain some additional metadata (operation IDs), and ensure fencing when failing over from one node to another.</p>

<p>Two-phase commit unfortunately is not sufficient to ensure that the transaction will only be executed once.</p>
<h4 class="no_toc" id="operation-identifiers">
  
  
    <a href="#operation-identifiers" class="anchor-heading" aria-labelledby="operation-identifiers"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> operation identifiers
  
  
</h4>
    
<p>You need to consider end-to-end flow of the request.</p>

<p>You can generate a unique identifier for an operation (such as a UUID) and include it as a hidden form field in the client application, or calculate a hash of all the relevant form fields to derive the operation ID. If the web browser submits the POST request twice, the two requests will have the same operation ID. You can then pass that operation ID all the way through to the database and check that you only ever execute one operation with a given ID. You can then save those requests to be processed, uniquely identified by the operation ID.</p>

<p>Is not enough to prevent a user from submitting a duplicate request if the first one times out. Solving the problem requires an end-to-end solution: a transaction indentifier that is passed all the way from the end-user client to the database.</p>

<p>Low-level reliability mechanisms such as those in TCP, work quite well, and so the remaining higher-level faults occur fairly rarely.</p>

<p>Transactions have long been seen as a good abstraction, they are useful but not enough.</p>

<p>It is worth exploring F=fault-tolerance abstractions that make it easy to provide application-specific end-to-end correctness properties, but also maintain good performance and good operational characteristics.</p>

          

          
        </main>
        

  <hr>
  <footer>
    
      <p><a href="#top" id="back-to-top">Back to top</a></p>
    

    <p class="text-small text-grey-dk-100 mb-0">Copyright © 2022 Michael McIntyre. </p>

    
      <div class="d-flex mt-2">
        
          <p class="text-small text-grey-dk-000 mb-0 mr-2">
            Page last modified: <span class="d-inline-block">Jul 11 2021 at 07:40 PM</span>.
          </p>
        
        
      </div>
    
  </footer>


      </div>
    </div>
    
      

<div class="search-overlay"></div>

    
  </div>

  
</body>
</html>
